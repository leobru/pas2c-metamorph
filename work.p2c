/*=p-,t-,s8,y+,k9,l1*/
extern _output_, _child_, pasinput, pasinfor;
//
label 9999;
//
const
    boilerplate = ' PASCAL 2 C METAMORPHOSIS (2025)';
//
    fnSQRT  = 0;  fnSIN  = 1;  fnCOS  = 2;  fnATAN  = 3;  fnASIN = 4;
    fnLN    = 5;  fnEXP  = 6;  fnABS =  7;  fnTRUNC = 8;  fnODD  = 9;
    fnORD   = 10; fnCHR  = 11; fnSUCC = 12; fnPRED  = 13; fnEOF  = 14;
    fnREF   = 15; fnEOLN = 16; /*   17   */ fnROUND = 18; fnCARD = 19;
    fnMINEL = 20; fnPTR  = 21; fnABSI = 22; /*   23   */  fn24 = 24;
//
    S3 = 0;
    S4 = 1;
    S5 = 2;
    S6 = 3;
    NoPtrCheck = 4;
    NoStackCheck = 5;
//
    DebugCode  = 45;
    DebugPrint = 46;
    DebugEntry = 47;
//
    ASN64 = 0360100;
//
    errBooleanNeeded = 0;
    errIdentAlreadyDefined = 2;
    errNoIdent = 3;
    errNotAType = 4;
    errNoConstant = 6;
    errConstOfOtherTypeNeeded = 7;
    errTypeMustNotBeFile = 9;
    errNotDefined = 11;
    errBadSymbol = 12;
    errNeedOtherTypesOfOperands = 21;
    errWrongVarTypeBefore = 22;
    errUsingVarAfterIndexingPackedArray = 28;
    errNoSimpleVarForLoop = 30;
    errTooManyArguments = 38;
    errNoCommaOrParenOrTooFewArgs = 41;
    errNumberTooLarge = 43;
    errVarTooComplex = 48;
    errEOFEncountered = 52;
    errFirstDigitInCharLiteralGreaterThan3 = 60;
//
    macro = 0100000000;
    mcJUMP = 2;
    mcACC2ADDR = 6;
    mcPOP = 4;
    mcPUSH = 5;
    mcMULTI = 7;
    mcADDSTK2REG = 8;
    mcADDACC2REG = 9;
    mcODD = 10;
    mcROUND = 11;
    mcMINEL = 15;
    mcPOP2ADDR = 19;
    mcCOND2INT = 20;
    mcPCKSTORE = 22;
    mcCARD = 23;
//
    ASCII0 =    04000007;
    E1 =        04000010;
    ZERO =      04000011;
    MULTMASK =  04000012;
    MANTISSA =  04000014;
    MINUS1 =    04000017;
    PLUS1 =     04000021;
    BITS15 =    04000022;
    REAL05 =    04000023;
    ALLONES =   04000024;
    HEAPPTR =   04000027;
//
    KATX =      0000000;
//   KSTX =      0010000;
    KXTS =      0030000;
    KADD =      0040000;
    KSUB =      0050000;
    KRSUB =     0060000;
    KAMX =      0070000;
    KXTA =      0100000;
    KAAX =      0110000;
    KAEX =      0120000;
    KARX =      0130000;
    KAVX =      0140000;
    KAOX =      0150000;
//   KDIV =      0160000;
    KMUL =      0170000;
    KAPX =      0200000;
    KAUX =      0210000;
    KACX =      0220000;
    KANX =      0230000;
    KYTA =      0310000;
//   KASN =      0360000;
    KNTR =      0370000;
    KATI =      0400000;
//   KSTI =      0410000;
    KITA =      0420000;
    KITS =      0430000;
    KMTJ =      0440000;
    KJADDM =    0450000;
    KE74 =      0740000;
    KUTC =      02200000;
    CUTC =      02200000U;
    KWTC =      02300000;
    CWTC =      02300000U;
    KVTM =      02400000;
    KUTM =      02500000;
//   KUZA =      02600000;
//   KU1A =      02700000;
    KUJ =       03000000;
    KVJM =      03100000;
    KVZM =      03400000;
//   KV1M =      03500000;
    KVLM =      03700000;
//
    I7 =        034000000;      /* frame pointer */
    I8 =        040000000;      /* const pointer */
    I9 =        044000000;      /* temp register */
    I10 =       050000000;      /* temp register */
    I11 =       054000000;      /* temp register */
    I12 =       060000000;      /* temp register */
    I13 =       064000000;      /* link register */
    I14 =       070000000;      /* temp register */
    SP =        074000000;      /* stack pointer, reg 15 */
//
    intZero = 0;
    halfWord  =  077777777U;
    extSymMask  =  043000000U;
    maxLineLen = 130;
    /*=A3*/
    litForward  =  ' FORWARD';
    litFortran  =  ' FORTRAN';
    litOct  =  '     OCT';
    /*=A2*/
type
    symbol = enum {
/*0B*/  IDENT,      INTCONST,   REALCONST,  CHARCONST,
        LTSY,       GTSY,       NOTSY,      LPAREN,
/*10B*/ LBRACK,     MULOP,      ADDOP,      RELOP,
        RPAREN,     RBRACK,     COMMA,      SEMICOLON,
/*20B*/ PERIOD,     ARROW,      COLON,      BECOMES,
        BEGINSY,    ENDSY,
        LABELSY,    CONSTSY,    TYPESY,     VARSY,
/*32B*/ FUNCSY,     VOIDSY,     ENUMSY,     PACKEDSY,
        ARRAYSY,    STRUCTSY,   FILESY,
/*41B*/ IFSY,       SWITCHSY,     WHILESY,
        FORSY,      WITHSY,     GOTOSY,
/*47B*/ ELSESY,     OFSY,       DOSY,
        TOSY,       DOWNTOSY,
/*54B*/ EXTERNSY,  DEFAULTSY,  NOSY
};
//
idclass = enum {
        TYPEID,     ENUMID,     ROUTINEID,  VARID,
        FORMALID,   FIELDID
};
//
insn = enum {
/*000*/ ATX,   STX,   OP2,   XTS,   ADD,   SUB,   RSUB,  AMX,
/*010*/ XTA,   AAX,   AEX,   ARX,   AVX,   AOX,   ADIVX, AMULX,
/*020*/ APX,   AUX,   ACX,   ANX,   EADD,  ESUB,  ASX,   XTR,
/*030*/ RTE,   YTA,   OP32,  OP33,  EADDI, ESUBI, ASN,   NTR,
/*040*/ ATI,   STI,   ITA,   ITS,   MTJ,   JADDM, ELFUN,
/*047*/ UTC,   WTC,   VTM,   UTM,   UZA,   U1A,   UJ,    VJM
};
//
setofsys = int; // set of ident .. downtosy;
//
operator = enum {
    SHLEFT,     SHRIGHT,
    SETAND,     SETXOR,     SETOR,
    MUL,        RDIVOP,     AMPERS,     IDIVOP,     IMODOP,
    PLUSOP,     MINUSOP,    OROP,       NEOP,       EQOP,
    LTOP,       GEOP,       GTOP,       LEOP,       INOP,
    IMULOP,
    SETSUB,     INTPLUS,    INTMINUS,   badop27,    badop30,
    badop31,    MKRANGE,    ASSIGNOP,   GETELT,     GETVAR,
    op36,       op37,       GETENUM,    GETFIELD,   DEREF,
    FILEPTR,    op44,       ALNUM,      PCALL,      FCALL,
    BOUNDS,     TOREAL,     NOTOP,      INEGOP,     RNEGOP,
    STANDPROC,  NOOP
};
//
opgen = enum {
    gen0,  STORE, LOAD,  gen3,  SETREG,
    SETREG9,  gen6,  gen7,  gen8,  gen9,
    gen10, gen11, gen12, FILEACCESS, gen14,
    BRANCH, gen16, LITINSN
};
//
// Flags for ops that can potentially be optimized if one operand is a constant
opflg = enum {
    opfCOMM, opfHELP, opfAND, opfOR, opfDIV, opfMOD, opfSHIFT,
    opfMULMSK, opfASSN, opfINV
};
//
kind = enum {
    kindReal, kindScalar, kindRange, kindPtr,
    kindArray, kindStruct, kindFile,
    kindCases
};
//
bitset = int; // set of 0..47;
//
eptr = @expr;
tptr = @types;
irptr = @identrec;
//
word = struct { switch int of
    0: {i: int};
    1: {r: real};
    2: {b: bool};
    3: {a: alfa};
    4: {t: packed array[0..7] of '_000' .. '_077'};
    7: {c: char};
    8: {cl: idclass};
    13: {m: bitset}
    };
//
oiptr = @oneinsn;
//
oneinsn  = struct {
    next: oiptr;
    mode, code, offset: int;
};
//
ilmode = enum {ilCONST, il1, il2, il3};
state = enum {st0, st1, st2};
//
insnltyp  = struct {
    next, next2: oiptr;
    typ: tptr;
    regsused: int;
    ilm: ilmode;
    ilf5: word;
    ilf6: int;
    ilf7: int;
    st: state;
    width, shift: int
};
//
types = struct {
    size,
    bits:   int;
    k:      kind;
    switch kind of
    kindReal:   {};
    kindRange:  {base:      tptr;
                 checker,
                 left,
                 right:     int};
    kindArray:  {abase,
                 range:     tptr;
                 pck:       bool;
                 perword,
                 pcksize:   int};
    kindScalar: {enums:     irptr;
                 numen,
                 start:     int};
    kindPtr:    {sbase:      tptr};
    kindFile:   {fbase:      tptr;
                 elsize:    int};
    kindStruct: {ptr1,
                 ptr2:      irptr;
                 flag,
                 pckrec:    bool};
    kindCases:  {sel:       word;
                 first,
                 next:      tptr;
                 r6:        tptr}
};
//
typechain = struct {
    next:         @typechain;
    type1, type2: tptr;
};
charmap   = packed array ['_000'..'_176'] of char;
textmap   = packed array ['_052'..'_177'] of '_000'..'_077';
//
four = array [1..4] of int;
entries   = array [1..42] of word;
//
expr = struct {
    switch operator of
    NOOP:       {val:    word;
                 op:     operator;
                 d1, d2: word};
    MUL:        {typ:    tptr;
                 d3:     word;
                 expr1, expr2: eptr};
    BOUNDS:     {d4, d5: word;
                 typ1, typ2: tptr};
    NOTOP:      {d6, d7: word;
                 id1, id2: irptr};
    STANDPROC:  {d8, d9: word;
                 num1, num2: int};
};
//
kword = struct {
    w:      word;
    sym:    symbol;
    op:     operator;
    next:   @kword;
};
//
strLabel = struct {
    next:       @strLabel;
    ident:      word;
    offset:     int;
    exitTarget: int;
};
//
numLabel = struct {
    id:         word;
    line:       int;
    frame:      int;
    offset:     int;
    next:       @numLabel;
    defined:    bool;
};
//
identrec = struct {
    id:     word;
    offset: int;
    next:   irptr;
    typ: tptr;
    cl: idclass;
    switch idclass of
    TYPEID,
    VARID:  {};
    ENUMID,
    FORMALID:
            {list: irptr; value: int};
    FIELDID:
            {maybeUnused: int;
             uptype: tptr;
             pckfield:  bool;
             shift:     int;
             width:     int};
    ROUTINEID:
            {low: int;
             high: word;
             argList, preDefLink: irptr;
             level, pos: int;
             flags: int
            };
};
extfilerec = struct {
    id:     word;
    offset: int;
    next:   @extfilerec;
    location,
    line: int
};
NumberFormat = enum {DECIMAL, OCTAL, FULLWORD};
//
var
    numFormat: NumberFormat;
    bigSkipSet, statEndSys, blockBegSys, statBegSys,
    skipToSet, lvalOpSet: setofsys;
    bool47z, bool48z, bool49z: bool;
    dataCheck: bool;
    jumpType: int;
    jumpTarget: int;
    exitTarget: int;
    charClass: operator;
    SY, prevSY: symbol;
    savedObjIdx: int;
    FcstCnt: int;
    symTabPos: int;
    entryPtCnt: int;
    fileBufSize: int;
    expr62z, expr63z: eptr;
    curInsnTemplate: int;
    linePos: int;
    prevErrPos: int;
    errsInLine: int;
    moduleOffset: int;
    lineStartOffset: int;
    curFrameRegTemplate: int;
    curProcNesting: int;
    totalErrors: int;
    lineCnt: int;
    bucket: int;
    strLen: int;
    heapCallsCnt: int;
    heapSize: int;
    arithMode: int;
    stmtName: alfa;
    keywordHashPtr: @kword;
    curVarKind: kind;
    curExternFile: @extfilerec;
    commentModeCH: char;
    unused85z: word;
    CH: char;
    sunused87z: word;
    debugLine: int;
    lineNesting: int;
    FcstCountTo500: int;
    objBufIdx: int;
    int92z, int93z, int94z: int;
    prevOpcode: int;
    charEncoding: int;
    int97z: int;
    atEOL: bool;
    checkTypes: bool;
    isDefined, putLeft, readNext: bool;
    errors: bool;
    declExternal: bool;
    rangeMismatch: bool;
    doPMD: bool;
    checkBounds: bool;
    fuzzReals: bool;
    fixMult: bool;
    bool110z: bool;
    allowCompat: bool;
    checkFortran: bool;
    outputFile: irptr;
    inputFile: irptr;
    programObj: irptr;
    hashTravPtr: irptr;
    uProcPtr: irptr;
    externFileList: @extfilerec;
    baseType, typ121z: tptr;
    pointerType: tptr;
    boolType: tptr;
    textType: tptr;
    intType: tptr;
    realType: tptr;
    charType: tptr;
    alfaType: tptr;
    arg1Type: tptr;
    arg2Type: tptr;
    numLabList: @numLabel;
    chain: @typechain;
    curToken: word;
    curVal: word;
    leftInsn: int;
    hashMask: word;
    curIdent: word;
    toAlloc: int;
    set145z: bitset;
    set146z:bitset;
    freeRegs:int;
    set148z: int;
    optSflags: word;
    uVarPtr: eptr;
    curExpr: eptr;
    insnList: @insnltyp;
    fileForOutput, fileForInput: @extfilerec;
    maxSmallString: int;
    smallStringType: array [2..6] of tptr;
    symTabCnt: int;
    symtabarray: array [1..80] of word;
    symtbidx: array [1..80] of int;
    iMulOpMap: array [MUL..IMODOP] of operator;
    iAddOpMap: array [PLUSOP..MINUSOP] of operator;
    entryPtTable: entries;
    frameRestore: array [3..6] of four;
    indexreg: array [1..15] of int;
    opToInsn: array [SHLEFT..op44] of int;
    opToMode: array [SHLEFT..op44] of int;
    opFlags: array [SHLEFT..op44] of opflg;
    funcInsn: array [0..23] of int;
    insnTemp: array [insn] of int;
    frameRegTemplate: int;
    constRegTemplate: int;
    disNormTemplate: int;
    lineBufBase: array [1..130] of char;
    errMapBase: array [0..9] of int;
    chrClassTabBase: array ['_000'..'_177'] of operator;
    kwordHashTabBase: array [0..127] of @kword;
    charSymTabBase: array ['_000'..'_177'] of symbol;
    symHashTabBase: array [0..127] of irptr;
    typeHashTabBase: array [0..127] of irptr;
    helperMap: array [1..99] of int;
    helperNames: array [1..99] of int;
//
    symTab: array [074000..075500] of int;
    systemProcNames: array [0..22] of int;
    resWordNameBase: array [0..26] of int;
    longSymCnt: int;
    longSymTabBase: array [1..90] of int;
    longSyms: array [1..90] of int;
    constVals: array [1..500] of alfa;
    constNums: array [1..500] of int;
    objBuffer: array [1..1024] of int;
    iso2text: array ['_052'..'_177'] of '_000'..'_077';
    fcst: file of int; /* last */
//
    pasinput: text;
//
    _child_: file of int;
//
    pasinfor: struct {
        /*0*/ listMode:     int;
        /*1*/ errors:       @bool;
        /*2*/ entryptr:     @entries;
        /*3*/ startOffset:  int;
      /*4-6*/ a0, a1, a4:   @charmap;
        /*7*/ a3:           @textmap;
     /*8-17*/ sizes:        array [1..10] of @int;
       /*18*/ flags:        int;
};
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//              PROGRAMME                 %
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void programme(var l2arg1z: int; l2idr2z: irptr);
label 22420, 22421, 23301;
var
    preDefHead, typelist, scopeBound, l2var4z, curIdRec, workidr: irptr;
    isPredefined, l2bool8z, inTypeDef: bool;
    l2var10z: eptr;
    l2int11z: int;
    l2var12z: word;
    l2typ13z, l2typ14z: tptr;
    l2var15z, l2var16z: @numLabel;
    strLabList: @strLabel;
//
    l2int18z, ii, localSize, l2int21z, jj: int;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//              PrintErrMsg               %
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void printErrMsg(errno: int);
type
    errtxt = packed array [0..100] of '_000'..'_077';
var
    errptr: @errtxt;
    errtext: array [0..100] of '_000'..'_077';
    i: int;
    c: char;
//
    function pasmitxt(errno: int): @errtxt;
        fortran;
//
    function pasisoxt(txtchar: '_000'..'_077'): char;
        fortran;
//
{ /* PrintErrMsg */
    write(' ');
    if (errno >= 200)
        write('system=', errno:0)
    else {
        if (errno > 88)
            printErrMsg(86)
        else if (errno in [16..18, 20]) {
            if (errno == 20)
                errno  =  ord(sy == ident)*2 + 1
            else
                write(curToken.i:0,' ');
        };
        errptr  =  pasmitxt(errno);
        unpack(errptr@, errtext, 0);
(loop)  for i = 0 to 100 do {
            c  =  pasisoxt(errtext[i]);
            if (c == '*')
                exit loop;
            write(c);
        };
        write(' ');
        if (errno in [17, 22])
            if (errno == 17)
                write(int97z:0)
            else
                write(stmtName);
    };
    if (errno != 86)
        writeln;
}; /* PrintErrMsg */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//              printTextWord             %
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void printTextWord(val: word);
//
    void PASTPR(val: word);
        extern;
//
{ /* printTextWord */
    write(' ');
    PASTPR(val)
}; /* printTextWord */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//              makeStringType                %
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void makeStringType(var res: tptr);
var span: tptr;
{
    if (maxSmallString >= strLen)
        res  =  smallStringType[strLen]
    else {
        new(span = 7);
        new(res, kindArray);
        with span@ do {
            size  =  1;
            checker  =  0;
            bits  =  12;
            k  =  kindRange;
            base  =  intType;
            left  =  1;
            right  =  strLen;
        };
        with res@ do {
            size  =  (strLen + 5) / 6;
            if (size == 1)
                bits  =  strLen * 8
            else
                bits  =  0;
            k  =  kindArray;
            base  =  charType;
            range  =  span;
            pck  =  true;
            perword  =  6;
            pcksize  =  8;
        }
    }
}; /* makeStringType */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//              addToHashTab              %
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void addToHashTab(arg: irptr);
{
    curVal.i  =  arg@.id.i & hashMask.i;
    mapai(curval.a, curval.i);
    arg@.next  =  symHashTabBase[curval.i];
    symHashTabBase[curval.i]  =  arg;
}; /* addToHashTab */
//
void error(errno: int);
    forward;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//              storeObjWord              %
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void storeObjWord(insn: int);
{
    objBuffer[objBufIdx]  =  insn;
    moduleOffset  =  moduleOffset + 1;
    if (objBufIdx == 1024) {
        error(49); /* errTooManyInsnsInBlock */
        objBufIdx  =  1
    } else
        objBufIdx  =  objBufIdx + 1;
}; /* storeObjWord */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//              form1Insn                 %
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void form1Insn(arg: int);
var
    insn, opcode: word;
    half1, half2: int;
    pos: int;
{
    insn.i  =  arg;
    opcode.i = insn.i & 077700000;
    if (opcode.i == insnTemp[UJ]) {
        if (prevOpcode == opcode.i)
            exit; /* no use in UJ after UJ */
        if (putLeft && (prevOpcode == 1)) {
            pos  =  objBufIdx - 1;
            if (objBuffer[pos] & [0..8] == [0, 1, 3..5, 8]) {
                prevOpcode  =  opcode.i;
                half1 = (insn.i & 077777U) << 24;
                half2 = (objBuffer[pos] >> 24) & 077777U;
                /* 15 24 00000 00 30 00000 */
                objBuffer[pos]  =  06640000003000000U |
                    half1 | half2;
                exit;
            }
       }
    };
    prevOpcode  =  opcode.i;
    if (putLeft) {
        leftInsn  =  (insn.i & halfWord) << 24;
        putLeft  =  false
    } else {
        putLeft  =  true;
        storeObjWord(leftInsn | (insn.i & halfWord))
    }
}; /* form1Insn */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void form2Insn(i1, i2: int);
{
    form1Insn(i1);
    form1Insn(i2);
}; /* form2Insn */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void form3Insn(i1, i2, i3: int);
{
    form2Insn(i1, i2);
    form1Insn(i3);
}; /* form3Insn */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void disableNorm;
{
    if (arithMode != 1) {
        form1Insn(disNormTemplate);
        arithMode  =  1;
    }
}; /* disableNorm */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getObjBufIdxPlus: int;
{
   if (putLeft)
       getObjBufIdxPlus  =  objBufIdx + 4096
   else
       getObjBufIdxPlus  =  objBufIdx
}; /* getObjBufIdxPlus */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void formJump(var arg: int);
var
    pos: int;
    isLeft: bool;
{
    if (prevOpcode != insnTemp[UJ]) {
        pos  =  getObjBufIdxPlus;
        isLeft  =  putLeft;
        form1Insn(jumpType + arg);
        if (putLeft == isLeft)
            pos  =  pos - 1;
        arg  =  pos;
    }
}; /* formJump */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void padToLeft;
{
    if (!putLeft)
        form1Insn(insnTemp[UTC]);
    prevOpcode  =  0;
}; /* padToLeft */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void formAndAlign(arg: int);
{
    form1Insn(arg);
    padToLeft;
    prevOpcode  =  1;
}; /* formAndAlign */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void putToSymTab(arg: int);
{
    symTab[symTabPos]  =  arg;
    if (symTabPos == 075500) {
        error(50); /* errSymbolTableOverflow */
        symTabPos  =  074000;
    } else
        symTabPos  =  symTabPos + 1;
}; /* putToSymTab */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocExtSymbol(sym: int): int;
var
    l3var1z: word;
    l3var2z: int;
{
    allocExtSymbol  =  symTabPos;
    if (curVal.i & halfWord != 0U) {
        for l3var2z to longSymCnt do
            if (curVal.i == longSyms[l3var2z]) {
                allocExtSymbol  =  longSymTabBase[l3var2z];
                exit
            };
        longSymCnt  =  longSymCnt + 1;
        if (longSymCnt >= 90) {
            error(51); /* errLongSymbolOverflow */
            longSymCnt  =  1;
        };
        longSymTabBase[longSymCnt]  =  symTabPos;
        longSyms[longSymCnt]  =  curVal.m;
        sym  =  sym | 020000000U;
    } else
        sym  =  sym | curVal.m;
    putToSymTab(sym);
}; /* allocExtSymbol */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getHelperProc(l3arg1z: int): int;
{
    if (helperMap[l3arg1z] == 0) {
        curVal.m  =  helperNames[l3arg1z];
        helperMap[l3arg1z]  =  allocExtSymbol(extSymMask);
    };
    getHelperProc  =  helperMap[l3arg1z] + (KVJM+I13);
}; /*getHelperProc */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void toFCST;
{
    write(FCST, curVal.i);
    FcstCnt  =  FcstCnt + 1;
}; /* toFCST */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function addCurValToFCST: int;
var
    low, high, mid: int;
{
    low  =  1;
    if (FcstCountTo500 == 0) {
        addCurValToFCST  =  FcstCnt;
        FcstCountTo500  =  1;
        constVals[1]  =  curVal.a;
        constNums[1]  =  FcstCnt;
        toFCST;
    } else {
        high  =  FcstCountTo500;
        do {
            mid  =  (low + high) / 2;
            if (curVal.a == constVals[mid]) {
                addCurValToFCST  =  constNums[mid];
                exit
            };
            if (curval.a < constVals[mid])
                high  =  mid - 1
            else
                low  =  mid + 1
        } while (high >= low);
        addCurValToFCST  =  FcstCnt;
        if (FcstCountTo500 != 500) {
            if (curval.a < constVals[mid])
                high  =  mid
            else
                high  =  mid + 1;
            for mid  =  FcstCountTo500 downto high do {
                low  =  mid + 1;
                constVals[low]  =  constVals[mid];
                constNums[low]  =  constNums[mid];
            };
            FcstCountTo500  =  FcstCountTo500 + 1;
            constVals[high]  =  curVal.a;
            constNums[high]  =  FcstCnt;
        };
        toFCST;
    }
}; /* addCurValToFCST */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocSymtab(arg: int): int;
var
    low, high, mid: int;
    value: word;
{
    low  =  1;
    value.i  =  arg;
    if (symTabCnt == 0) {
        allocSymtab  =  symTabPos;
        symTabCnt  =  1;
        symTabArray[1].i  =  arg;
        symtbidx[1]  =  symTabPos;
    } else {
        high  =  symTabCnt;
        do {
            mid  =  (low + high) / 2;
            if (value == symTabArray[mid]) {
                allocSymtab  =  symtbidx[mid];
                exit
            };
            if ( value.a < symTabArray[mid].a)
                 high  =  mid - 1
            else
                 low  =  mid + 1;
        } while (high >= low);
        allocSymtab  =  symTabPos;
        if (symTabCnt != 80) {
            if (value.a < symTabArray[mid].a)
                high  =  mid
            else
                high  =  mid + 1;
            for mid  =  symTabCnt downto high do {
                low  =  mid + 1;
                symTabArray[low]  =  symTabArray[mid];
                symtbidx[low]  =  symtbidx[mid];
            };
            symTabCnt  =  symTabCnt + 1;
            symTabArray[high]  =  value;
            symtbidx[high]  =  symTabPos;
        }
    };
    putToSymTab(value.i);
}; /* allocSymtab */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getFCSToffset: int;
var
    offset: word;
{
    getFCSToffset  =  addCurValToFCST;
    offset  = ;
    if (offset.i < 2048) {
        /* empty */
    } else if (offset.i >= 4096)
        error(204)
    else {
        getFCSToffset  =  allocSymtab(offset.i | 040000000U) - 070000;
        exit
    }
}; /* getFCSToffset */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function nrOfBits(value: int): int;
{
    curVal.i  =  value;
    curVal.m  =  curVal.m & [7..47];
    nrOfBits  =  48-minel(curval.m);
}; /* nrOfBits */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void defineRange(var res: tptr; l, r: int);
var
    temp: tptr;
    dummyloc: word;
{
    new(temp=7);
    with temp@ do {
        size  =  1;
        bits  =  48;
        base  =  res;
        checker  =  0;
        k  =  kindRange;
        curVal.i  =  l;
        curVal.m  =  curVal.m | intZero;
        left  =  curVal.i;
        curVal.i  =  r;
        curVal.m  =  curVal.m | intZero;
        right  =  curVal.i;
        if (left >= 0)
            bits  =  nrOfBits(curVal.i);
        res  =  temp
    }
}; /* defineRange */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function getValueOrAllocSymtab(value: int): int;
{
    curVal.i  =  value;
    curVal.i  =  curVal.i % 32768;
    if (040000 >= curVal.i)
        getValueOrAllocSymtab  =  curVal.i
    else
        getValueOrAllocSymtab  =
            allocSymtab((curVal.i | 040000000U) & halfWord);
}; /* getValueOrAllocSymtab */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P0715(mode, arg: int);
label 1;
var
    addr, insn, leftHalf: int;
    isLarge: bool;
    work, offset: int;
{
    if (mode == 0) {
        padToLeft;
        curVal.i  =  moduleOffset;
1:      addr  =  curval.i & 077777U;
        leftHalf = curVal.i << 24;
        while (arg != 0) {
            if (4096 < arg) {
                isLarge  =  true;
                arg  =  arg - 4096;
            } else isLarge  =  false;
            insn  =  objBuffer[arg];
            if (isLarge) {
                curVal.i  = (insn >> 24) & 077777U | intZero;
                insn  =  insn & 07770000077777777U | leftHalf;
            } else {
                curVal.m  =  intZero | insn & 077777U;
                insn  =  insn & 07777777777700000U | addr;
            };
            objBuffer[arg]  =  insn;
            arg  =  curVal.i;
        };
        exit;
    } else if (mode == 2) {
        form1Insn(KVTM+I14 + curVal.i);
        if (curVal.i == 074001)
            form1Insn(KUTM+I14 + FcstCnt);
        form3Insn(KITA+14, insnTemp[ASN] + arg, KAOX+I7+1);
        form1Insn(KATX+I7+1);
        exit;
    } else if ((mode == 1) || (mode < -2)) {
        arg  =  arg - curVal.i;
        offset  =  getFCSToffset;
        if (mode == 1)
            work  =  getHelperProc(68) + (-064200000) /* P/DA */
        else
            work  =  -mode;
        curVal.i  =  arg;
        arg  =  getFCSToffset;
        form3Insn(KATX+SP+1, KSUB+I8 + offset, work);
        form3Insn(KRSUB+I8 + arg, work, KXTA+SP+1);
        exit;
    } else if (mode == -1) {
        form1Insn(KVTM+I14 + lineCnt);
        formAndAlign(getHelperProc(arg));
        exit;
    };
    curVal.i  =  mode;
    goto 1;
}; /* P0715 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void endOfLine;
var
    unused: array [1..14] of int;
    err, errPos, prevPos, listMode,
    startPos, lastErr: int;
//
    void OBPROG(var start, fin: int);
        extern;
{
    listMode  =  pasinfor.listMode;
    if ((listMode != 0) || (errsInLine != 0))
    {
        write(' ', (lineStartOffset + PASINFOR.startOffset):5 oct,
              lineCnt:5, lineNesting:3, commentModeCH);
        startPos  =  13;
        do
            linePos  =  linePos-1
        while ((lineBufBase[linePos]  == ' ') && (linePos != 0));
        for err to linePos do {
            _output_@ = lineBufBase[err];
            put(_output_)
        };
        writeln;
        if (errsInLine != 0) {
            write('*****':startPos, ' ':errMapBase[0], '0');
            lastErr  =  errsInLine - 1;
            for err to lastErr do {
                errPos  =  errMapBase[err];
                prevPos  =  errMapBase[err-1];
                if (errPos != prevPos) {
                    if (prevPos + 1 != errPos)
                        write(' ':(errPos-prevPos-1));
                    write(chr(err + 48));
                }
            };
            writeln;
            errsInLine  =  0;
            prevErrPos  =  0;
        }
    };
    if ((listMode == 2) && (moduleOffset != lineStartOffset)) {
        OBPROG(objBuffer[objBufIdx - moduleOffset + lineStartOffset],
               objBuffer[objBufIdx-1]);
    };
    lineStartOffset  =  moduleOffset;
    linePos  =  0;
    lineCnt  =  lineCnt + 1;
    if (eof(pasinput)) {
        error(errEOFEncountered);
        goto 9999;
    }
}; /* endOfLine */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void requiredSymErr(sym: symbol);
{
    if (linePos != prevErrPos)
        error(ord(sym) + 88);
}; /* requiredSymErr */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void readToPos80;
{
    while (linePos < 81) {
        linePos  =  linePos + 1;
        lineBufBase[linePos]  =  PASINPUT@;
        if (linePos != 81)  get(PASINPUT);
    };
    endOfLine
}; /* readToPos80 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void inSymbol;
label
    1473, 1, 2, 2175, 2233, 2320;
var
    localBuf: array [0..130] of char;
    tokenLen, tokenIdx: int;
    expSign: bool;
    l3var135z: irptr;
    expMultiple, expValue: real;
    curChar: char;
    numstr: array [1..17] of word;
    expLiteral, expMagnitude: int;
    val: int;
    chord: int;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void nextCH;
{
    do {
        atEOL  =  eoln(PASINPUT);
        CH  =  PASINPUT@;
        get(PASINPUT);
        linePos  =  linePos + 1;
        lineBufBase[linePos]  =  CH;
    } while ((maxLineLen < linePos) && !atEOL);
}; /* nextCH */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseComment;
var
    badOpt, flag: bool;
    c: char;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void readOptVal(var res: int; limit: int);
{
    nextCH;
    res  =  0;
    while (('9' >= CH) && (CH >= '0')) {
        res  =  10 * res + ord(CH) - ord('0');
        nextCH;
        badOpt  =  false;
    };
    if (limit < res)  badOpt  =  true;
}; /* readOptVal */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void readOptFlag(var res: bool);
{
    nextCH;
    if ((CH == '-') || (CH == '+')) {
        res  =  CH == '+';
        badOpt  =  false;
    };
    nextCH
}; /* readOptFlag */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* parseComment */
    nextCH;
    if (CH == '=') {
        do {
        nextCH;
        badOpt  =  true;
        switch (CH) {
        'D': {
            readOptVal(curVal.i, 15);
            optSflags.m  =  optSflags.m & [0..40] | curVal.m & [41..47];
        };
        'Y': readOptFlag(allowCompat);
        'E': readOptFlag(declExternal);
        'S': {
            readOptVal(curVal.i, 9);
            if (curVal.i == 3)  lineCnt  =  1
            else if (curVal.i in [4..9])
                optSflags.m  =  optSflags.m | [curVal.i - 3]
        };
        'F': readOptFlag(checkFortran);
        'L': readOptVal(PASINFOR.listMode, 3);
        'P': readOptFlag(doPMD);
        'T': readOptFlag(checkBounds);
        'A': readOptVal(charEncoding, 3);
        'C': readOptFlag(checkTypes);
        'R': readOptFlag(fuzzReals);
        'M': readOptFlag(fixMult);
        'B': readOptVal(fileBufSize, 4);
        'K': readOptVal(heapSize, 23);
        };
        if (badOpt)
            error(54); /* errErrorInPseudoComment */
        } while (CH == ',');
    };
    do {
        while (CH != '*') {
            c  =  commentModeCH;
            commentModeCH  =  '*';
            if (atEOL)
                endOfLine;
            nextCH;
            commentModeCH  =  c;
        };
        nextCH
    } while (CH != '/');
    nextCH;
}; /* parseComment */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* inSymbol */
        if (dataCheck) {
            error(errEOFEncountered);
            readToPos80;
            goto 9999;
        };
1473:
        while ((CH == ' ') && !atEOL)
            nextCH;
        if ('_200' < CH) {
            lineBufBase[linePos]  =  ' ';
            chord  =  ord(CH);
            for jj  =  130 to chord do {
                linePos  =  linePos + 1;
                lineBufBase[linePos]  =  ' ';
            };
            nextCH;
            goto 1473;
        };
        if (atEOL) {
            endOfLine;
            nextCH;
            goto 1473;
        };
        hashTravPtr  =  NIL;
        SY  =  charSymTabBase[CH];
        charClass  =  chrClassTabBase[CH];
(lexer)
        if (SY != NOSY) {
            switch (SY) {
            IDENT: {
1:              curToken.i  = 0U;
                tokenLen  =  1;
                do {
                    curVal.c  =  iso2text[CH];
                    nextCH;
                    if (8 >= tokenLen) {
                        tokenLen  =  tokenLen + 1;
                        curToken.i  =  (curToken.i << 6) | curVal.i;
                    };
                } while (chrClassTabBase[CH] == ALNUM);
                curVal.i  =  curToken.i & hashMask.i;
                mapAI(curVal.a, bucket);
                curIdent  =  curToken;
                keywordHashPtr  =  kwordHashTabBase[bucket];
                while (keywordHashPtr != NIL) {
                    if (keywordHashPtr@.w == curToken) {
                        SY  =  keywordHashPtr@.sym;
                        charClass  =  keywordHashPtr@.op;
                        exit lexer;
                    };
                    keywordHashPtr  =  keywordHashPtr@.next;
                };
                isDefined  =  false;
                SY  =  IDENT;
                switch (int93z) {
                0: {
                    hashTravPtr  =  symHashTabBase[bucket];
                    while (hashTravPtr != NIL) {
                        if (hashTravPtr@.offset == curFrameRegTemplate)
                        {
                            if (hashTravPtr@.id != curIdent)
                                hashTravPtr  =  hashTravPtr@.next
                            else {
                                isDefined  =  true;
                                exit lexer;
                            }
                        } else
                            exit lexer;
                    };
                };
                1: {
2:                  hashTravPtr  =  symHashTabBase[bucket];
                    while (hashTravPtr != NIL) {
                        if (hashTravPtr@.id != curIdent)
                            hashTravPtr  =  hashTravPtr@.next
                        else
                            exit lexer;
                    };
                };
                2: {
                    if (expr63z == NIL)
                        goto 2;
                    expr62z  =  expr63z;
                    l3var135z  =  typeHashTabBase[bucket];
                    if (l3var135z != NIL) {
                        while (expr62z != NIL) {
                            val  =  expr62z@.typ2@.size;
                            hashTravPtr  =  l3var135z;
                            while (hashTravPtr != NIL) {
                                if ((hashTravPtr@.id == curIdent)
                                && (hashTravPtr@.value == val))
                                    exit lexer;
                                hashTravPtr  =  hashTravPtr@.next;
                            };
                            expr62z  =  expr62z@.expr1;
                        };
                    };
                    goto 2;
                };
                3: {
                    hashTravPtr  =  typeHashTabBase[bucket];
                    while (hashTravPtr != NIL) {
                        with hashTravPtr@ do {
                            if ((id == curIdent) &&
                               (typ121z == uptype))
                                exit lexer;
                            hashTravPtr  =  next;
                       }
                   }
                };
                };
            }; /* IDENT */
            INTCONST: { /*=m-*/
                SY  =  INTCONST;
                tokenLen  =  0;
                do {
                    tokenLen  =  tokenLen + 1;
                    if (tokenLen <= 17)
                        numstr[tokenLen].i  =  ord(CH)-ord('0')
                    else {
                        error(55); /* errMoreThan16DigitsInNumber */
                        tokenLen  =  1;
                    };
                    nextCH;
                } while (charSymTabBase[CH] == INTCONST);
(octdec)        {
                    if (numstr[1].i == 0) {
                        numFormat  =  OCTAL;
                        if (CH == 'U') {
                            numFormat = FULLWORD;
                            nextCH;
                        }
                    } else {
                        numFormat  =  DECIMAL;
                        exit octdec;
                    };
                    curToken.c  =  chr(0);
                    for tokenIdx to tokenLen do {
                        if (7 < numstr[tokenIdx].i)
                            error(20); /* errDigitGreaterThan7 */
                        curToken.m = (curToken.m << 3) |
                            numstr[tokenIdx].m & [45..47];
                    };
                    if (numFormat == OCTAL) {
                        if (curToken.m & [0..6] != []) {
                            error(errNumberTooLarge);
                            curToken.i  =  1;
                        } else
                            curToken.m  =  curToken.m | intZero;
                    };
                    exit lexer;
                }; /* octdec */
                curToken.i  =  0;
                for tokenIdx to tokenLen do {
                    if (109951162777 >= curToken.i)
                        curToken.i  =  10 * curToken.i +
                            numstr[tokenIdx].i
                    else {
                        error(errNumberTooLarge);
                        curToken.i  =  1;
                    };
                };
                if (CH == 'U') {
                    curToken.m = curToken.m & [7..47];
                    numFormat = FULLWORD;
                    nextCH;
                    exit lexer;
                };
                expMagnitude  =  0;
                if (CH == '.') {
                    nextCH;
                    if (CH == '.') {
                        CH  =  ':';
                        exit lexer
                    };
                    curToken.r  =  curToken.i;
                    SY  =  REALCONST;
                    if (charSymTabBase[CH] != INTCONST)
                        error(56) /* errNeedMantissaAfterDecimal */
                    else
                        do {
                            curToken.r  =  10.0*curToken.r + ord(CH)-48;
                            expMagnitude  =  expMagnitude-1;
                            nextCH;
                        } while (charSymTabBase[CH] == INTCONST);
                };
                if (CH == 'E') {
                    if (expMagnitude == 0) {
                        curToken.r  =  curToken.i;
                        SY  =  REALCONST;
                    };
                    expSign  =  false;
                    nextCH;
                    if (CH == '+')
                        nextCH
                    else if (CH == '-') {
                        expSign  =  true;
                        nextCH
                    };
                    expLiteral  =  0;
                    if (charSymTabBase[CH] != INTCONST)
                        error(57) /* errNeedExponentAfterE */
                    else
                        do {
                            expLiteral  =  10 * expLiteral + ord(CH) - 48;
                            nextCH
                        } while (charSymTabBase[CH] == INTCONST);
                    if (expSign)
                        expMagnitude  =  expMagnitude - expLiteral
                    else
                        expMagnitude  =  expMagnitude + expLiteral;
                };
                if (expMagnitude != 0) {
                    expValue  =  1.0;
                    expSign  =  expMagnitude < 0;
                    expMagnitude  =  abs(expMagnitude);
                    expMultiple  =  10.0;
                    if (18 < expMagnitude) {
                        expMagnitude  =  1;
                        error(58); /* errExponentGreaterThan18 */
                    };
                    do {
                        if (odd(expMagnitude))
                            expValue  =  expValue * expMultiple;
                        expMagnitude  =  expMagnitude / 2;
                        if (expMagnitude != 0)
                            expMultiple  =  expMultiple*expMultiple;
                    } while (expMagnitude != 0);
                    if (expSign)
                        curToken.r  =  curToken.r / expValue
                    else
                        curToken.r  =  curToken.r * expValue;
                };
                exit lexer
            }; /* INTCONST */ /*=m+*/
            CHARCONST: {
(loop)          {
                    for tokenIdx  =  6 to 130 do {
                        nextCH;
                        if (charSymTabBase[CH] == CHARCONST) {
                            nextCH;
                            if (charSymTabBase[CH] != CHARCONST)
                                exit loop
                            else
                                goto 2233;
                        };
                        if (atEOL) {
2175:                       error(59); /* errEOLNInStringLiteral */
                            exit loop
                        } else if (((CH == chr(035)) ||
                                   (CH == '_'))
                               && (charSymTabBase[PASINPUT@] == INTCONST))
                         {
                            expLiteral  =  0;
                            for tokenLen to 3 do {
                                nextCH;
                                if ('7' < CH)
                                    error(
                                        errFirstDigitInCharLiteralGreaterThan3
                                    );
                                expLiteral  =  8*expLiteral + ord(CH) - 48;
                            };
                            if (255 < expLiteral)
                                error(errFirstDigitInCharLiteralGreaterThan3);
                            localBuf[tokenIdx]  =  chr(expLiteral);
                        } else
2233:                       with PASINFOR do {
                                if (charEncoding == 3) {
                                    if ((ch < '*') || ('_176' < CH))
                                        curChar  =  chr(0)
                                    else {
                                        curChar  =  iso2text[CH];
                                    }
                                } else {
                                    curChar  =  CH;
                                };
                                localBuf[tokenIdx]  =  curChar;
                            };
                    };
                    goto 2175
                };
                strLen  =  tokenIdx - 6;
                if (strLen == 0) {
                   error(61); /* errEmptyString */
                   strLen  =  1;
                   goto 2320
                } else if (strLen == 1) {
                    SY  =  CHARCONST;
                    tokenLen  =  1;
                    curToken.c  =  chr(0);
                    unpck(localBuf[0], curToken.a);
                    pck(localBuf[tokenLen], curToken.a);
                    exit lexer;
                } else 2320: {
                    curVal.a  =  '      ';
                    SY  =  LTSY;
                    unpck(localBuf[tokenIdx], curVal.a);
                    pck(localBuf[6], curToken.a);
                    curVal  = ;
                    if (strLen <= 6)
                        exit lexer
                    else if ((charEncoding == 3) && (strLen == 8)) {
                        pack(localbuf, 6, curToken.t);
                        curVal = ;
                        SY = INTCONST;
                        exit lexer
                    } else {
                        curToken.i  =  FcstCnt;
                        tokenLen  =  6;
                        (loop) {
                            toFCST;
                            tokenLen  =  tokenLen + 6;
                            if (tokenIdx < tokenLen)
                                exit lexer;
                            pck(localBuf[tokenLen], curVal.a);
                            goto loop
                        }
                    }
                };
            }; /* CHARCONST */
            LTSY: {
                SY  =  RELOP;
                nextCH;
                switch (CH) {
                '=': {
                    charClass = LEOP;
                    nextCH;
                };
                '<': {
                    SY = MULOP;
                    charClass = SHLEFT;
                    nextCH;
                };
                ':': {
                    SY = BEGINSY;
                    nextCH;
                }
                }
            }; /* LTOP */
            GTSY: {
                SY  =  RELOP;
                nextCH;
                switch (CH) {
                '>': {
                    SY = MULOP;
                    charClass = SHRIGHT;
                    nextCH;
                };
                '=':  {
                    charClass  =  GEOP;
                    nextCH
                }
                }
            }; /* GTOP */
            BECOMES: {
                nextCH;
                if (CH == '=') {
                    nextCH;
                    SY = RELOP;
                }
            };
            COLON: {
                nextCH;
                if (CH == '>') {
                    SY = ENDSY;
                    nextCH;
                }
            };
            NOTSY: {
                if (charClass == NEOP) {
                    nextCH;
                    if (CH == '=') {
                        SY = RELOP;
                        nextCH;
                    }
                } else
                    nextCH
            };
            ADDOP: {
                if (charClass == OROP) {
                    nextCH;
                    if (CH == '|') nextCH
                    else charClass = SETOR;
                } else
                    nextCH;
            };
            MULOP: {
               if (charClass == AMPERS) {
                   nextCH;
                   if (CH == '&') nextCH
                   else charClass = SETAND;
               } else if (charClass == RDIVOP) {
                   nextCH;
                   switch (CH) {
                   '*': {
                       parseComment;
                       goto 1473
                   };
                   '/': {
                       while (!atEOL) nextCH;
                       goto 1473;
                   }
                   }
               } else
                   nextCH
            };
            LPAREN, LBRACK, RELOP, RPAREN, RBRACK,
            COMMA, SEMICOLON, ARROW: {
                nextCH;
            };
            PERIOD: {
                nextCH;
                if (CH == '.') {
                    nextCH;
                    SY  =  COLON;
                    charClass  =  NOOP
                } else {
                    if (prevSY == ENDSY)
                        dataCheck  =  true;
                }
            };
            } /* switch */
        } else
            nextCH;
        prevSY  =  SY;
        commentModeCH  =  ' ';
        int93z  =  int92z;
}; /* inSymbol */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void error;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void skipToEnd;
var
    sym: symbol;
{
    sym  =  SY;
    while ((sym != ENDSY) || (SY != PERIOD)) {
        sym  =  SY;
        inSymbol
    };
    if (CH == 'D')
        while (SY != ENDSY)
            inSymbol;
    goto 9999;
};
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* error */
    errors  =  true;
    bool110z  = ;
    if (((linePos != prevErrPos) && (9 >= errsInLine))
        || (errno == 52))
     {
        write(' ');
        totalErrors  =  totalErrors + 1;
        errMapBase[errsInLine]  =  linePos;
        errsInLine  =  errsInLine + 1;
        prevErrPos  =  linePos;
        write('******', errno:0);
        printErrMsg(errno);
        if (60 < totalErrors) {
            writeln;
            endOfLine;
            printErrMsg(53);
            skipToEnd
        }
    }
};
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void skip(toset: setofsys);
{
    while (!(SY IN toset))
        inSymbol;
}; /* skip */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void test1(sym: symbol; toset: setofsys);
{
    if (SY != sym) {
        requiredSymErr(sym);
        skip(toset)
    } else
        inSymbol;
}; /* test1 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void errAndSkip(errno: int; toset: setofsys);
{
    error(errno);
    skip(toset)
}; /* errAndSkip */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseLiteral(var litType: tptr; var litValue: word;
    allowSign: bool);
label
    99;
var
    l3var1z: operator;
{
    litValue  =  curToken;
    if (GTSY < SY) {
        if (allowSign && (charClass IN [PLUSOP, MINUSOP])) {
            l3var1z  =  charClass;
            inSymbol;
            parseLiteral(litType, litValue, false);
            if (litType != intType) {
                error(62); /* errIntNeeded */
                litType  =  intType;
                litValue.i  =  1;
            } else {
                if (l3var1z == MINUSOP)
                    litValue.i  =  -litValue.i;
            };
        } else
99:     {
            litType  =  NIL;
            error(errNoConstant);
        }
    } else
        switch (SY) {
        IDENT: {
            if ((hashTravPtr == NIL) ||
               (hashTravPtr@.cl != ENUMID))
                goto 99;
            litType  =  hashTravPtr@.typ;
            litValue.i  =  hashTravPtr@.value;
        };
        INTCONST:
            litType  =  intType;
        REALCONST:
            litType  =  realType;
        CHARCONST:
            litType  =  charType;
        LTSY:
            makeStringType(litType);
        } /* switch */
}; /* parseLiteral */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P2672(var l3arg1z: irptr; l3arg2z: irptr);
var
    l3var1z: bool;
    l3var2z: int;
    l3var3z, l3var4z: irptr;
{
    if (l3arg1z == NIL) {
        curVal.i  =  l3arg2z@.id.i & hashMask.i;
        mapAI(curVal.a, l3var2z);
        l3var1z  =  true;
        l3arg1z  =  symHashTabBase[l3var2z];
    } else {
        l3var1z  =  false;
    };
    if (l3arg1z == l3arg2z) {
        if (l3var1z) {
            symHashTabBase[l3var2z]  =
                symHashTabBase[l3var2z]@.next;
        } else {
            l3arg1z  =  l3arg2z@.next;
        };
    } else {
        l3var3z  =  l3arg1z;
        while (l3var3z != l3arg2z) {
            l3var4z  =  l3var3z;
            if (l3var3z != NIL) {
                l3var3z  =  l3var3z@.next;
            } else {
                exit
            }
        };
        l3var4z@.next  =  l3arg2z@.next;
    }
}; /* P2672 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isFileType(typtr: tptr): bool;
{
    isFileType  =  (typtr@.k == kindFile) ||
        (typtr@.k == kindStruct) && typtr@.flag;
}; /* isFileType */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function knownInType(var rec: irptr): bool;
{
    if (typelist != NIL) {
        rec  =  typelist;
        while (rec != NIL) {
            if (rec@.id == curIdent) {
                knownInType  =  true;
                exit
            };
            rec  =  rec@.next;
        }
    };
    knownInType  =  false;
}; /* knownInType */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void checkSymAndRead(sym: symbol);
{
    if (SY != sym)
        requiredSymErr(sym)
    else
        inSymbol
}; /* checkSymAndRead */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function typeCheck(type1, type2: tptr): bool;
label
    1;
var
    baseMatch: bool;
    kind1, kind2: kind;
    link: @typechain;
    basetyp1, basetyp2: tptr;
    enums1, enums2: irptr;
    span1, span2: int;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void allocWithTypeCheck;
{
    new(link);
    link@  =  [chain, basetyp1, basetyp2];
    chain  =  link;
    typeCheck  =  typeCheck(basetyp1, basetyp2);
}; /* allocWithTypeCheck */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function checkRecord(l4arg1z, l4arg2z: tptr): bool;
var
    l4var1z: bool;
{
    l4var1z  =  (l4arg1z == NIL) || (l4arg2z == NIL);
    if (l4var1z) {
        checkRecord  =  l4arg1z == l4arg2z;
    } else {
        checkRecord  =  typeCheck(l4arg1z@.base, l4arg2z@.base) &&
                 checkRecord(l4arg1z@.next, l4arg2z@.next);
    };
}; /* checkRecord */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* typeCheck */
    rangeMismatch  =  false;
    if (type1@.k == kindRange) {
        baseType  =  type1@.base;
    } else {
        baseType  =  type1;
    };
    if (!checkTypes || (type1 == type2))
1:      typeCheck  =  true
    else
        with type1@ do {
            kind1  =  k;
            kind2  =  type2@.k;
            if (kind1 == kind2) {
                switch (kind1) {
                kindReal:
                    /* empty */;
                kindScalar: {
(chain)             if (type1@.numen == type2@.numen) {
                        enums1  =  type1@.enums;
                        enums2  =  type2@.enums;
                        while ((enums1 != NIL) && (enums2 != NIL)) {
                            if (enums1@.id != enums2@.id)
                                exit chain;
                            enums1  =  enums1@.list;
                            enums2  =  enums2@.list;
                        };
                        if ((enums1 == NIL) && (enums2 == NIL))
                            goto 1;
                    }
                };
                kindRange: {
                    baseMatch  =  (type1@.base == type2@.base);
                    baseType  =  type1@.base;
                    rangeMismatch  =  (type1@.left != type2@.left) ||
                                (type1@.right != type2@.right);
                    typeCheck  =  baseMatch;
                    exit
                };
                kindPtr: {
                    if ((type1 == pointerType) || (type2 == pointerType))
                        goto 1;
                    basetyp1  =  type1@.base;
                    basetyp2  =  type2@.base;
                    if (chain != NIL) {
                        link  =  chain;
                        while (link != NIL) with link@ do {
                            if ((type1 == basetyp1) &&
                               (type2 == basetyp2) ||
                               (type2 == basetyp1) &&
                               (type1 == basetyp2))
                                goto 1;
                            link  =  next;
                        };
                        allocWithTypeCheck;
                    } else {
                        setup(type1);
                        allocWithTypeCheck;
                        chain  =  NIL;
                        rollup(type1);
                        exit
                    }
                };
                kindArray: {
                    with type1@.range@ do
                        span1  =  right - left;
                    with type2@.range@ do
                        span2  =  right - left;
                    if (typeCheck(type1@.base, type2@.base) &&
                       (span1 == span2) &&
                       (type1@.pck == type2@.pck) &&
                       !rangeMismatch) {
                        if (type1@.pck) {
                            if (type1@.pcksize == type2@.pcksize)
                                goto 1
                        } else
                            goto 1
                    }
                };
                kindFile: {
                    if (typeCheck(type1@.base, type2@.base))
                        goto 1;
                };
                kindStruct: {
                    if (checkRecord(type1@.first, type2@.first))
                        goto 1;
                }
                } /* switch */
            } else {
                if (kind1 == kindRange) {
                    rangeMismatch  =  true;
                    baseType  =  type2;
                    if (type1@.base == type2)
                        goto 1;
                } else if ((kind2 == kindRange) &&
                          (type1 == type2@.base))
                    goto 1;
            };
            typeCheck  =  false;
        }
}; /* typeCheck */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3307(l3arg1z: irptr): int;
var
    l3var1z: int;
    l3var2z: irptr;
{
    l3var2z  =  l3arg1z@.argList;
    l3var1z  =  0;
    if (l3var2z != NIL)
        while (l3var2z != l3arg1z) {
            l3var1z  =  l3var1z + 1;
            l3var2z  =  l3var2z@.list;
        };
    F3307  =  l3var1z;
}; /* F3307 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function makeNameWithStars(isProc: bool): int;
{
    while (curVal.m & [0..5] == []) {
        curVal.i  =  curVal.i << 6;
    };
    makeNameWithStars  =  curVal.i;
}; /* makeNameWithStars */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void formOperator(l3arg1z: opgen);
var
    l3int1z, l3int2z, l3int3z: int;
    nextInsn: int;
    l3var5z: eptr;
    flags: opflg;
    l3var7z,
    l3var8z: word;
    l3bool9z: bool;
    l3var10z, l3var11z: word;
    saved: @insnltyp;
    l3bool13z: bool;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genOneOp;
label
    3556;
var
    insnBufIdx: int;
    l4var2z, l4var3z, l4var4z: int;
    l4var5z: word;
    l4inl6z, l4inl7z, l4inl8z: oiptr;
    l4var9z: int;
    insnBuf: array [1..200] of word;
    curInsn: word;
    tempInsn: word;
    l4oi212z: oiptr;
    l4var213z: bool;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P3363;
{
    if (l4var213z)
        form1Insn(insnTemp[XTA])
    else
        form1Insn(KXTA+E1)
}; /* P3363 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void  addInsnToBuf(insn: int);
{
    insnBuf[insnBufIdx].i  =  insn;
    insnBufIdx  =  insnBufIdx + 1;
}; /* addInsnToBuf */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void add2InsnsToBuf(insn1, insn2: int);
{
    insnBuf[insnBufIdx].i  =  insn1;
    insnBuf[insnBufIdx+1].i  =  insn2;
    insnBufIdx  =  insnBufIdx + 2;
}; /* add2InsnsToBuf */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function F3413: bool;
{
    l4inl7z  =  l4inl6z;
    while (l4inl7z != NIL) {
        if (l4inl7z@.mode == curInsn.i) {
            F3413  =  true;
            while (l4inl7z@.code == macro) {
                l4inl7z  =  ptr(l4inl7z@.offset);
            };
            exit
        } else {
            l4inl7z  =  l4inl7z@.next;
        }
    };
    F3413  =  false;
}; /* F3413 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void addJumpInsn(opcode: int);
{
    if (!F3413) {
        new(l4inl7z);
        l4inl7z@.next  =  l4inl6z;
        l4inl7z@.mode  =  curInsn.i;
        l4inl7z@.code  =  0;
        l4inl7z@.offset  =  0;
        l4inl6z  =  l4inl7z;
    };
    addInsnToBuf(macro + opcode + ord(l4inl7z))
}; /* addJumpInsn */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* genOneOp */
    if (insnList == NIL)
         exit;
    set145z  =  set145z | insnList@.regsused;
    l4oi212z  =  insnList@.next2;
    l4var9z  =  0370007;
    insnBufIdx  =  1;
    if (l4oi212z == NIL)
        exit;
    l4inl6z  =  NIL;
    while (l4oi212z != NIL) {
        tempInsn.i  =  l4oi212z@.code;
        l4var4z  =  tempInsn.i -  macro;
        curInsn.i  =  l4oi212z@.offset;
        switch (l4oi212z@.mode) {
         0: ;
         1: if (arithMode != 1) {
                addInsnToBuf(0370007);
                arithMode  =  1
            };
         2: arithMode  =  1;
         3: if (arithMode != 2) {
                addInsnToBuf(insnTemp[NTR]);
                arithMode  =  2;
            };
         4: arithMode  =  2;
        }; /* switch */
        l4oi212z  =  l4oi212z@.next;
        if (l4var4z >= 0) {
            switch (l4var4z) {
            mcCARD: add2InsnsToBuf(KACX, KAEX+ZERO);
            21: goto 3556;
            0:  addJumpInsn(insnTemp[UZA]);
            1:  addJumpInsn(insnTemp[U1A]);
            2: {
                tempInsn.i  =  curInsn.i % 4096;
                curInsn.i  =  curInsn.i / 4096;
                addJumpInsn(insnTemp[UJ]);
                curInsn.i  =  tempInsn.i;
3556:           if (F3413)
                    addInsnToBuf(2*macro+ord(l4inl7z))
                else
                    error(206);
            };
            3: {
                 tempInsn.i  =  curInsn.i % 4096;
                 curInsn.i  =  curInsn.i / 4096;
                 l4var213z  =   F3413;
                 l4inl8z  =  l4inl7z;
                 curInsn.i  =  tempInsn.i;
                 l4var213z  =  l4var213z && F3413;
                 if (l4var213z)
                    with l4inl7z@ do {
                        code  =  macro;
                        offset  =  ord(l4inl8z);
                    }
                else
                    error(207);
            };
            mcCOND2INT: addInsnToBuf(3*macro + curInsn.i);
            mcPOP: {
                if (insnBuf[insnBufIdx-1].m & [21:23, 28:35] == [])
                    insnBuf[insnBufIdx-1].m  =  insnBuf[insnBufIdx-1].m | [35]
                else
                    addInsnToBuf(KXTA+SP)
            };
            mcPUSH:
(blk)       {
                if (l4oi212z != NIL) {
                    tempInsn.i  =  l4oi212z@.code;
                    if (tempInsn.m & [21:23, 28:35] == [32]) {
                        l4oi212z@.code  =
                            tempInsn.i - insnTemp[XTA] + insnTemp[XTS];
                        exit blk
                    }
                };
                addInsnToBuf(KATX+SP);
            };
            mcACC2ADDR:  add2InsnsToBuf(KATI+14, KUTC+I14);
            mcMULTI: {
                addInsnToBuf(getHelperProc(12));        /* P/MI */
            };
            mcADDSTK2REG:  add2InsnsToBuf(KWTC+SP, KUTM+
                               indexreg[curInsn.i]);
            mcADDACC2REG:  add2InsnsToBuf(KATI+14, KJADDM+I14 + curInsn.i);
            mcODD: {
                add2InsnsToBuf(KAAX+E1, KAEX+ZERO);
            };
            mcROUND: {
                addInsnToBuf(KADD+REAL05);                /* round */
                add2InsnsToBuf(KNTR+7, KADD+ZERO)
            };
            14: { add2InsnsToBuf(indexreg[curInsn.i] + KVTM,
                               KITA + curInsn.i);
            };
            mcMINEL: {
                add2InsnsToBuf(KANX+ZERO, KSUB+PLUS1);   /* minel */
            };
            16: add2InsnsToBuf(insnTemp[XTA], KATX+SP + curInsn.i);
            17: {
                addInsnToBuf(KXTS);
                add2InsnsToBuf(KATX+SP+1, KUTM+SP + curInsn.i)
            };
            18: add2InsnsToBuf(KVTM+I10, getHelperProc(65)); /* P/B7 */
            mcPOP2ADDR: {
                addInsnToBuf(KVTM+I14);
                add2InsnsToBuf(KXTA+SP, KATX+I14)
            };
            mcPCKSTORE: {
                add2InsnsToBuf(KVTM+I14, KXTA+I14);
                curVal.i  =  040077777U;
                add2InsnsToBuf(allocSymtab(curVal.i) + (KXTS+SP),
                               KAAX+I8 + curInsn.i);
                add2InsnsToBuf(KAEX+SP, KATX+I14)
            };
            }; /* switch */
        } else {
            if (28 in tempInsn.m) {
                addInsnToBuf(getValueOrAllocSymtab(curInsn.i)+tempInsn.i);
            } else {
                curval.i  =  curInsn.i % 32768;
                if (curVal.i < 2048)
                    addInsnToBuf(tempInsn.i + curInsn.i)
                else
(stmt)          if ((curVal.i >= 28672) || (curVal.i < 4096)) {
                    addInsnToBuf(
                        allocSymtab((curVal.i | 040000000U) & halfWord)
                        + tempInsn.i - 28672);
                } else {
                    add2InsnsToBuf(getValueOrAllocSymtab(curVal.i)
                                   + insnTemp[UTC], tempInsn.i);
                }
            }
        }
    };
    insnBufIdx  =  insnBufIdx-1;
    for l4var4z  =  insnBufIdx downto 1 do {
        curInsn  =  insnBuf[l4var4z];
        if ((curInsn.i == insnTemp[NTR]) ||
           (curInsn.i == 0370007))
         {
            l4var3z  =  l4var4z - 1;
            l4var213z  =  false;
(loop)      if (l4var3z < 1)  exit loop else {
                tempInsn.m  =  insnBuf[l4var3z].m & 03700000U;
                if ((tempInsn.i == CUTC) || (tempInsn.i == CWTC))
                 {
                    l4var3z  =  l4var3z-1;
                    goto loop;
                }
            };
/* one word shorter
(loop)      while (l4var3z >= 1) {
                tempInsn.m  =  insnBuf[l4var3z].m * [28:32];
                if ((tempInsn.i != CUTC) && (tempInsn.i != CWTC))
                    exit loop;
                l4var3z  =  l4var3z-1;
            };
*/
            l4var3z  =  l4var3z + 1;
            if (l4var3z != l4var4z) {
                for l4var2z  =  l4var4z-1 downto l4var3z do {
                    insnBuf[l4var2z+1]  =  insnBuf[l4var2z]
                };
            };
            insnBuf[l4var3z]  =  curInsn;
        };
    };
    for l4var4z to insnBufIdx do
(iter) {
        curInsn  =  insnBuf[l4var4z];
        tempInsn.m  =  curInsn.m & [0, 1, 3, 23:32];
        if (tempInsn.i == KATX+SP) {
            l4var2z  =  l4var4z + 1;
            while (insnBufIdx + 1 != l4var2z) {
                curVal.m  =  insnBuf[l4var2z].m & [0, 1, 3, 23, 28:35];
                tempInsn.m  =  curVal.m & [0, 1, 3, 23, 28:32];
                if (curVal.i == insnTemp[XTA]) {
                    insnBuf[l4var2z].m  =
                        insnBuf[l4var2z].m ^ [32, 34, 35];
                    exit iter;
                } else if (curVal.i == insnTemp[ITA]) {
                    insnBuf[l4var2z].m  =  insnBuf[l4var2z].m | [35];
                    exit iter;
                } else if ((curVal.i == insnTemp[NTR]) ||
                    (tempInsn.i == insnTemp[UTC]) ||
                    (tempInsn.i == insnTemp[WTC]) ||
                    (tempInsn.i == insnTemp[VTM]))
                    l4var2z  =  l4var2z + 1
                else {
                    l4var2z  =  insnBufIdx + 1;
                }
            };
        };
        if (curInsn.i == insnTemp[UTC])
            exit iter;
        if (curInsn.i < macro) {
            form1Insn(curInsn.i);
            tempInsn.m  =  curInsn.m & [28:32];
            if ((tempInsn.i == 03100000U) || /* VJM */
               (tempInsn.i == 0500000U))    /* ELFUN */
             {
                padToLeft;
                prevOpcode  =  1;
            };
            exit iter;
        };
        if (curInsn.i >= 3*macro) {
            curInsn.i  =  curInsn.i - (3*macro);
            if (curInsn.i >= 4096) {
                l4var213z  =  true;
                curInsn.i  =  curInsn.i - 4096;
            } else {
                l4var213z  =  false;
            };
            if (curInsn.i == 0)
                form1Insn(insnTemp[UZA] + moduleOffset + 2);
            P3363;
            form1Insn(insnTemp[UJ] + 2 + moduleOffset);
            padToLeft;
            if (curInsn.i != 0) {
                if (not F3413)
                    error(211);
                P0715(0, l4inl7z@.code);
            };
            l4var213z  =  not l4var213z;
            P3363;
            padToLeft;
            exit iter
        };
        if (curInsn.i >= 2*macro) {
            l4inl7z  =  ptr(curInsn.i - (2*macro));
            P0715(0, l4inl7z@.code);
            l4inl7z@.offset  =  moduleOffset;
        } else {
            curInsn.i  =  curInsn.i - macro;
            curVal.m  =  curInsn.m & [0, 1, 3, 28:32];
            jumpType  =  curVal.i;
            curVal.m  =  [0, 1, 3, 33:47] & curInsn.m;
            l4inl7z  =  ptr(curVal.i);
            formJump(l4inl7z@.code);
            jumpType  =  insnTemp[UJ];
            exit iter
        }
    }; /* loop */
    insnList  =  NIL;
    while (l4inl6z != NIL) {
        with l4inl6z@ do
            if (offset == 0) {
                jumpTarget  =  code;
                exit;
            } else
                l4inl6z  =  next;
    };
    set146z  =  set146z ~ set145z;
}; /* genOneOp */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void addToInsnList(insn: int);
var elt: oiptr;
{
    new(elt);
    with elt@ do {
        next  =  NIL;
        mode  =  0;
        code  =  insn;
        offset  =  0;
    };
    with insnList@ do {
        if (next == NIL)
            next2  =  elt
        else
            next@.next  =  elt;
        next  =  elt
    }
}; /* addToInsnList */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void addInsnAndOffset(insn, l4arg2z: int);
{
    addToInsnList(insn);
    insnlist@.next@.offset  =  l4arg2z
}; /* addInsnAndOffset */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void addxToInsnList(insn: int);
var
    elt: oiptr;
{
    new(elt);
    with elt@ do {
        next  =  insnList@.next2;
        mode  =  0;
        code  =  insn;
        offset  =  0;
    };
    if (insnList@.next2 == NIL) {
        insnList@.next  =  elt;
    };
    insnList@.next2  =  elt;
}; /* addxToInsnList */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void prepLoad;
label
    4545, 4602;
var
    helper, l4int2z, l4int3z: int;
    l4typ4z: tptr;
    l4var5z: kind;
    l4st6z: state;
    l4bool7z, l4bool8z, l4bool9z: bool;
{
    l4typ4z  =  insnList@.typ;
    with insnList@ do {
        switch (ilm) {
        ilCONST: {
            curVal  =  ilf5;
            if (l4typ4z@.size == 1)
                curVal.i  =  getFCSToffset;
            addToInsnList(constRegTemplate + curInsnTemplate + curVal.i);
        };
        il1: {
            helper  =  insnList@.ilf7;
            l4int2z  =  insnList@.ilf5.i;
            l4int3z  =  insnList@.ilf6;
            if (15 < helper) {
                /* empty */
            } else {
                if (helper == 15) { /* P/CP */
                    addToInsnList(macro + mcACC2ADDR);
                } else {
                    helper  =  indexreg[insnList@.ilf7];
                    if ((l4int2z == 0) && (insnList@.st == st0)) {
                        addInsnAndOffset(helper + curInsnTemplate,
                                         l4int3z);
                        goto 4602;
                    } else {
                        addToInsnList(helper + insnTemp[UTC]);
                    }
                }
            };
            l4st6z  =  insnList@.st;
            if (l4st6z == st0) {
                addInsnAndOffset(l4int2z + curInsnTemplate, l4int3z);
            } else {
                l4var5z  =  l4typ4z@.k;
                if ((l4var5z < kindArray) ||
                   (l4var5z == kindStruct) && (s6 in optSflags.m)) {
                    l4bool7z  =  true;
                    l4bool8z  =  typeCheck(l4typ4z, intType);
                } else {
                    l4bool7z  =  false;
                    l4bool8z  =  false;
                };
                if (l4st6z == st1) {
                    if ((l4int3z != l4int2z) ||
                       (helper != 18) || /* P/RC */
                       (l4int2z != 0))
                        addInsnAndOffset(l4int2z + insnTemp[XTA],
                                         l4int3z);
                    l4int3z  =  insnList@.shift;
                    l4int2z  =  insnList@.width;
                    l4bool9z  =  true;
                    helper  =  l4int3z + l4int2z;
                    if (l4bool7z) {
                        if (30 < l4int3z) {
                            addToInsnList(ASN64-48 + l4int3z);
                            addToInsnList(insnTemp[YTA]);
                            if (helper == 48)  /* P/RDR */
                                l4bool9z  =  false;
                        } else {
                            if (l4int3z != 0)
                                addToInsnList(ASN64 + l4int3z);
                        };
                        if (l4bool9z) {
                            curVal.m  =  [(48 - l4int2z)..47];
                            addToInsnList(KAAX+I8 + getFCSToffset);
                        }
                    } else {
                        if (helper != 48)
                            addToInsnList(ASN64-48 + helper);
                        curVal.m  =  [0..(l4int2z-1)];
                        addToInsnList(KAAX+I8 + getFCSToffset);
                    };
                    if (l4bool8z)
                        addToInsnList(KAEX+ZERO);
                } else {
                    if (l4bool7z)
                        helper  =  ord(l4bool8z)+74 /* P/LDAR[IN] */
                    else
                        helper  =  56; /* P/RR */
                    addToInsnList(getHelperProc(helper));
                    insnList@.next@.mode  =  1;
                }
            };
            goto 4545;
        };
        il2: {
4545:       if (bool49z && (l4typ4z == boolType) &&
               (16 in insnList@.regsused))
                addToInsnList(KAEX+E1);
        };
        il3: {
            if (bool49z)
                addInsnAndOffset(macro+mcCOND2INT,
                    ord(16 in insnList@.regsused)*010000 + insnList@.ilf5.i);
        };
        }; /* switch */
4602:
    }; /* with */
    with insnList@ do {
        ilm  =  il2;
        regsused  =  regsused | [0];
    };
}; /* prepLoad */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P4606;
{
    prepLoad;
    addToInsnList(macro + mcPUSH)
}; /* P4606 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void setAddrTo(reg: int);
label
    4650, 4654;
var
    l4var1z: word;
    l4int2z, opCode, l4var4z, l4var5z,
    l4var6z, regField: int;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void getOffset;
{
      l4var6z = insnList@.ilf6 % 32768;
}; /* getOffset */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* setAddrTo */
    with insnList@ do {
        l4int2z  =  ilf7;
        opCode  =  insnTemp[VTM];
        regField  =  indexreg[reg];
        l4var4z  =  ilf5.i;
        regsused  =  regsused | [reg];
        if (ilm == ilCONST) {
            curVal  =  ilf5;
            if (typ@.size == 1)
                curVal.i  =  addCurValToFCST;
            l4var6z  =  curVal.i;
            l4var5z  =  074001;
            goto 4654;
        } else if (l4int2z == 18) {
4650:       getOffset;
            if (l4var4z == indexreg[1]) {
                l4var5z  =  074003;
4654:           l4var1z.i  =  macro * l4var5z + l4var6z;
                l4var6z  =  allocSymtab(l4var1z.i & 0777777777777U);
                addToInsnList(regField + opCode + l4var6z);
            } else if (l4var4z != 0) {
                addInsnAndOffset(l4var4z + insnTemp[UTC], l4var6z);
                addToInsnList(regField + opCode);
            } else {
                addInsnAndOffset(regField + opCode, l4var6z);
            }
        } else if (l4int2z == 17) {
            getOffset;
            l4var4z  =  insnList@.ilf6;
            l4var5z  =  insnList@.next@.code - insnTemp[UTC];
            if (l4var4z != 0) {
                l4var1z.i  =  macro * l4var5z + l4var4z;
                l4var5z  =  allocSymtab(l4var1z.i & 0777777777777U);
            };
            insnList@.next@.code  =  regField + l4var5z + opCode;
        } else if (l4int2z == 16) {
            getOffset;
            if (l4var4z != 0)
                addToInsnList(l4var4z + insnTemp[UTC]);
            addInsnAndOffset(regField + opCode, l4var6z);
        } else if (l4int2z == 15) {
            addToInsnList(insnTemp[ATI] + reg);
            opCode  =  insnTemp[UTM];
            goto 4650;
        } else {
            addToInsnList(indexreg[l4int2z] + insnTemp[UTC]);
            goto 4650;
        }
    }; /* with */
    insnList@.ilm  =  il1;
    insnList@.ilf7  =  reg;
    insnList@.ilf6  =  0;
    insnList@.ilf5.i  =  0;
}; /* setAddrTo */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void prepStore;
var
    l4int1z: int;
    l4int2z, l4int3z: int;
    l4bool4z, l4bool5z: bool;
    l4st6z: state;
    l4var7z: kind;
{
    with insnList@ do
        l4int1z  =  ilf7;
    if (15 < l4int1z) {
        /* nothing? */
    } else if (l4int1z == 15) {
        addToInsnList(macro + mcACC2ADDR)
    } else {
        addToInsnList(indexreg[l4int1z] + insnTemp[UTC]);
    };
    l4bool4z  =  0 in insnList@.regsused;
    l4st6z  =  insnList@.st;
    if ((l4st6z != st0) || l4bool4z)
        addxToInsnList(macro + mcPUSH);
    if (l4st6z == st0) {
        if (l4bool4z) {
            addInsnAndOffset(insnList@.ilf5.i + insnTemp[UTC],
                             insnList@.ilf6);
            addToInsnList(macro+mcPOP2ADDR);
        } else {
            addInsnAndOffset(insnList@.ilf5.i, insnList@.ilf6);
        }
    } else {
        l4var7z  =  insnList@.typ@.k;
        l4int1z  =  insnList@.typ@.bits;
        l4bool5z  =  (l4var7z < kindArray) ||
                     (l4var7z == kindStruct) && (S6 in optSflags.m);
        if (l4st6z == st1) {
            l4int2z  =  insnList@.shift;
            l4int3z  =  l4int2z + insnList@.width;
            if (l4bool5z) {
                if (l4int2z != 0)
                    addxToInsnList(ASN64 - l4int2z);
            } else {
                if (l4int3z != 48)
                    addxToInsnList(ASN64 + 48 - l4int3z);
            };
            addInsnAndOffset(insnTemp[UTC] + insnList@.ilf5.i,
                             insnList@.ilf6);
            curVal.m  =  [0..47] ~ [(48-l4int3z)..(47 -l4int2z)];
            addInsnAndOffset(macro+mcPCKSTORE, getFCSToffset);
        } else {
            if (not l4bool5z) {
                l4int2z  =  (insnList@.width - l4int1z);
                if (l4int2z != 0)
                    addxToInsnList(ASN64 - l4int2z);
                addxToInsnList(insnTemp[YTA]);
                addxToInsnList(ASN64 - l4int1z);
            };
            addToInsnList(getHelperProc(77)); /* "P/STAR" */
            insnList@.next@.mode  =  1;
        }
    }
}; /* prepStore */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P5117(op: operator);
{
    addInsnAndOffset(curFrameRegTemplate, localSize);
    new(curExpr);
    with curExpr@ do
        typ  =  insnList@.typ;
    genOneOp;
    curExpr@.op  =  op;
    curExpr@.num1  =  localSize;
    localSize  =  localSize + 1;
    if (l2int21z < localSize)
        l2int21z  =  localSize;
}; /* P5117 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function insnCount: int;
var
    cnt: int;
    cur: oiptr;
{
    cnt  =  0;
    cur  =  insnList@.next2;
    while (cur != NIL) {
        cur  =  cur@.next;
        cnt  =  cnt + 1;
    };
    insnCount  =  cnt;
}; /* insnCount */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genFullExpr(exprToGen: eptr);
label
    7567, 7760, 10075, 10122;
var
    arg1Const, arg2Const: bool;
    otherIns: @insnltyp;
    arg1Val, arg2Val: word;
    curOP: operator;
    work: int;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P5155;
{
    prepLoad;
    insnList@.ilm  =  il1;
    insnList@.st  =  st0;
    insnList@.ilf6  =  0;
    insnList@.ilf5.i  =  0;
    insnList@.ilf7  =  18;
}; /* P5155 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genDeref;
label
    5220;
var
    l5var1z, l5var2z: word;
    doPtrCheck: bool;
{
    doPtrCheck  =  checkBounds && not (NoPtrCheck in optSflags.m)
               && (curOP == DEREF);
    if (not doPtrCheck && (
        (insnList@.st == st0) ||
        (insnList@.st == st1) &&
        (insnList@.shift == 0)))
     {
        l5var1z.i  =  insnList@.ilf7;
        l5var2z.i  =  insnList@.ilf6;
        if ((l5var1z.i == 18) || (l5var1z.i == 16)) {
5220:       addInsnAndOffset((insnList@.ilf5.i + insnTemp[WTC]), l5var2z.i);
        } else {
            if (l5var1z.i == 17) {
                if (l5var2z.i == 0) {
                    insnList@.next@.code  =  insnList@.next@.code +
                                                insnTemp[XTA];
                } else
                    goto 5220;
            } else if (l5var1z.i == 15) {
                addToInsnList(macro + mcACC2ADDR);
                goto 5220;
            } else {
                addInsnAndOffset((indexreg[l5var1z.i] + insnTemp[WTC]),
                                 l5var2z.i);
            }
        }
    } else {
        P5155;
        if (doPtrCheck) {
            addToInsnList(KVTM+I14 + lineCnt);
            addToInsnList(getHelperProc(7)); /* "P/CA"*/
            insnList@.next@.mode  =  1;
        };
        addToInsnList(macro + mcACC2ADDR);
    };
    insnList@.ilf6  =  0;
    insnList@.ilf5.i  =  0;
    insnList@.ilf7  =  16;
}; /* genDeref */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genHelper;
{
    P4606;
    saved  =  insnList;
    insnList  =  otherIns;
    prepLoad;
    addToInsnList(getHelperProc(nextInsn));
    insnList@.regsused  =  insnList@.regsused | saved@.regsused | [11:14];
    saved@.next@.next  =  insnList@.next2;
    insnList@.next2  =  saved@.next2;
}; /* genHelper */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void prepMultiWord;
var
    l5var1z: bool;
    l5var2z: @insnltyp;
{
    l5var1z  =  12 in otherIns@.regsused;
    setAddrTo(12);
    if (l5var1z) {
        addToInsnList(KITA+12);
        addToInsnList(macro + mcPUSH);
    };
    l5var2z  =  insnList;
    insnList  =  otherIns;
    setAddrTo(14);
    if (l5var1z) {
        addToInsnList(macro + mcPOP);
        addToInsnList(KATI+12);
    };
    l5var2z@.regsused  =  insnList@.regsused | l5var2z@.regsused;
    l5var2z@.next@.next  =  insnList@.next2;
    l5var2z@.next  =  insnList@.next;
    insnList  =  l5var2z;
}; /* prepMultiWord */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genCheckBounds(l5arg1z: tptr);
var
    l5var1z: int;
    l5var2z, l5var3z, l5var4z: word;
{
    l5var1z  =  l5arg1z@.checker;
    if (l5var1z == 0) {
        curVal.i  =  l5arg1z@.left;
        l5var4z.i  =  l5arg1z@.right;
        if (l5arg1z@.base != intType) {
            curVal.m  =  curVal.m & [7:47];
            l5var4z.m  =  l5var4z.m & [7:47];
        };
        prevOpcode  =  0;
        formAndAlign(KUJ+5 + moduleOffset);
        l5arg1z@.checker  =  moduleOffset;
        l5var1z  =  moduleOffset;
        P0715(1, l5var4z.i);
        formAndAlign(KUJ+I13);
    };
    prepLoad;
    addToInsnList(KVTM+I14 + lineCnt);
    addToInsnList(KVJM+I13 + l5var1z);
    insnList@.next@.mode  =  1;
}; /* genCheckBounds */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void negateCond;
{
    if (insnList@.ilm == ilCONST) {
        insnList@.ilf5.b  =  not insnList@.ilf5.b;
    } else {
        insnList@.regsused  =  insnList@.regsused ^ [16];
    }
}; /* negateCond */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void tryFlip(commutes: bool);
label
    100, 22, 33;
var
    l5var1z: int;
    l5var2z: @insnltyp;
{
    if (not (0 in otherIns@.regsused)) {
        l5var1z  =  0;
    } else if (not (0 in insnList@.regsused)) {
        l5var1z  =  ord(commutes) + 1;
    } else {
        l5var1z  =  3;
    };
    switch (l5var1z) {
    0:
100: {
        prepLoad;
        saved  =  insnList;
        insnList  =  otherIns;
        curInsnTemplate  =  nextInsn;
        prepLoad;
        curInsnTemplate  =  insnTemp[XTA];
    };
    1:
        if (nextInsn == insnTemp[SUB]) {
            nextInsn  =  insnTemp[RSUB];
            goto 22;
        } else
            goto 33;
   2:
22: {
        saved  =  insnList;
        insnList  =  otherIns;
        otherIns  =  saved;
        goto 100;
    };
    3:
33: {
        prepLoad;
        addToInsnList(indexreg[15] + nextInsn);
        l5var2z  =  insnList;
        insnList  =  otherIns;
        P4606;
        saved  =  insnList;
        insnList  =  l5var2z;
    };
    }; /* switch */
    insnList@.next@.mode  =  0;
    saved@.next@.next  =  insnList@.next2;
    insnList@.next2  =  saved@.next2;
    insnList@.regsused  =  insnList@.regsused | [0];
}; /* tryFlip */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genBoolAnd;
var
    l5var1z, l5var2z: bool;
    l5var3z, l5var4z, l5var5z, l5var6z, l5var7z: int;
    l5ins8z: @insnltyp;
    l5var9z: word;
{
    if (arg1Const) {
        if (arg1Val.b)
            insnList  =  otherIns;
    } else if (arg2Const) {
        if (not arg2Val.b)
            insnList  =  otherIns;
    } else {
        l5var1z  =  16 in insnList@.regsused;
        l5var2z  =  16 in otherIns@.regsused;
        l5var5z  =  int94z;
        int94z  =  int94z + 1;
        bool49z  =  false;
        l5var6z  =  ord(l5var1z) + macro;
        l5var7z  =  ord(l5var2z) + macro;
        if (insnList@.ilm == il3) {
            l5var3z  =  insnList@.ilf5.i;
        } else {
            l5var3z  =  0;
            prepLoad;
        };
        if (otherIns@.ilm == il3) {
            l5var4z  =  otherIns@.ilf5.i;
        } else {
            l5var4z  =  0;
        };
        l5var9z.m  =  (insnList@.regsused | otherIns@.regsused);
        if (l5var3z == 0) {
            if (l5var4z == 0) {
                addInsnAndOffset(l5var6z, l5var5z);
                l5ins8z  =  insnList;
                insnList  =  otherIns;
                prepLoad;
                addInsnAndOffset(l5var7z, l5var5z);
            } else {
                if (l5var2z) {
                    addInsnAndOffset(l5var6z, l5var5z);
                    l5ins8z  =  insnList;
                    insnList  =  otherIns;
                    addInsnAndOffset(macro + mcJUMP,
                                     010000 * l5var5z + l5var4z);
                } else {
                    addInsnAndOffset(l5var6z, l5var4z);
                    l5var5z  =  l5var4z;
                    l5ins8z  =  insnList;
                    insnList  =  otherIns;
                }
            };
        } else {
            if (l5var4z == 0) {
                if (l5var1z) {
                    addInsnAndOffset(macro + mcJUMP,
                                     010000 * l5var5z + l5var3z);
                    l5ins8z  =  insnList;
                    insnList  =  otherIns;
                    prepLoad;
                    addInsnAndOffset(l5var7z, l5var5z);
                } else {
                    l5ins8z  =  insnList;
                    insnList  =  otherIns;
                    prepLoad;
                    addInsnAndOffset(l5var7z, l5var3z);
                    l5var5z  =  l5var3z;
                };
            } else {
                if (l5var1z) {
                    if (l5var2z) {
                        addInsnAndOffset(macro + mcJUMP,
                                         010000 * l5var5z + l5var3z);
                        l5ins8z  =  insnList;
                        insnList  =  otherIns;
                        addInsnAndOffset(macro + mcJUMP,
                                         010000 * l5var5z + l5var4z);
                    } else {
                        addInsnAndOffset(macro + mcJUMP,
                                         010000 * l5var4z + l5var3z);
                        l5ins8z  =  insnList;
                        insnList  =  otherIns;
                        l5var5z  =  l5var4z;
                    }
                } else {
                    l5ins8z  =  insnList;
                    insnList  =  otherIns;
                    l5var5z  =  l5var3z;
                    if (l5var2z)
                        addInsnAndOffset(macro + mcJUMP,
                                         010000 * l5var3z + l5var4z)
                    else
                        addInsnAndOffset(macro + 3,
                                         010000 * l5var3z + l5var4z);
                }
            }
        };
        insnList@.regsused  =  l5var9z.m ~ [16];
        l5ins8z@.next@.next  =  insnList@.next2;
        insnList@.next2  =  l5ins8z@.next2;
        insnList@.ilm  =  il3;
        insnList@.ilf5.i  =  l5var5z;
        bool49z  =  true;
    }
}; /* genBoolAnd */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genGetElt;
var
    l5var1z, dimCnt, curDim, l5var4z, l5var5z, l5var6z,
        l5var7z, l5var8z: int;
    insnCopy: insnltyp;
    copyPtr, l5ins21z: @insnltyp;
    l5var22z, l5var23z: word;
    l5var24z: bool;
    l5var25z: bool;
    l5var26z, l5var27z: tptr;
    l5ilm28z: ilmode;
    l5var29z: eptr;
    getEltInsns: array [1..10] of @insnltyp;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function myminel(l6arg1z: int): int;
{
    myminel  =  minel(l6arg1z);
}; /* myminel */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* genGetElt */
    dimCnt  =  0;
    l5var29z  =  exprToGen;
    while (l5var29z@.op == GETELT) {
        genFullExpr(l5var29z@.expr2);
        dimCnt  =  dimCnt + 1;
        getEltInsns[dimCnt]  =  insnList;
        l5var29z  =  l5var29z@.expr1;
    };
    genFullExpr(l5var29z);
    l5ins21z  =  insnList;
    insnCopy  =  insnList@;
    copyPtr  =  ref(insnCopy);
    l5var22z.m  =  freeRegs;
    for curDim to dimCnt do
       l5var22z.m  =  l5var22z.m ~ getEltInsns[curDim]@.regsused;
    for curDim  =  dimCnt downto 1 do {
        l5var26z  =  insnCopy.typ@.base;
        l5var27z  =  insnCopy.typ@.range;
        l5var25z  =  insnCopy.typ@.pck;
        l5var7z  =  l5var27z@.left;
        l5var8z  =  l5var26z@.size;
        if (not l5var25z)
            insnCopy.ilf6  =  insnCopy.ilf6 - l5var8z * l5var7z;
        insnList  =  getEltInsns[curDim];
        l5ilm28z  =  insnList@.ilm;
        if (l5ilm28z == ilCONST) {
            curVal  =  insnList@.ilf5;
            curVal.m  =  curVal.m | intZero;
            if ((curVal.i < l5var7z) ||
               (l5var27z@.right < curVal.i))
                error(29); /* errIndexOutOfBounds */
            if (l5var25z) {
                l5var4z  =  curVal.i - l5var7z;
                l5var5z  =  insnCopy.typ@.perword;
                insnCopy.regsused  =  insnCopy.regsused | [0];
                insnCopy.ilf6  =  l5var4z / l5var5z + insnCopy.ilf6;
                l5var6z  =  (l5var5z-1-l5var4z % l5var5z) *
                           insnCopy.typ@.pcksize;
                switch (insnCopy.st) {
                st0: insnCopy.shift  =  l5var6z;
                st1: insnCopy.shift  =  insnCopy.shift + l5var6z +
                                           insnCopy.typ@.bits - 48;
                st2: error(errUsingVarAfterIndexingPackedArray);
                }; /* switch */
                insnCopy.width  =  insnCopy.typ@.pcksize;
                insnCopy.st  =  st1;
            }  else {
                insnCopy.ilf6  =  curVal.i  * l5var26z@.size +
                                  insnCopy.ilf6;
            }
        } else {
            if (checkBounds) {
                l5var24z  =  typeCheck(l5var27z, insnList@.typ);
                if (rangeMismatch)
                    genCheckBounds(l5var27z);
            };
            if (l5var8z != 1) {
                prepLoad;
                if (l5var27z@.base == intType) {
                    l5var4z  =  KYTA+64;
                } else {
                    l5var4z  =  KYTA+64-40;
                };
                addToInsnList(insnCopy.typ@.perword);
                insnList@.next@.mode  =  1;
                if (l5var7z >= 0)
                    addToInsnList(l5var4z)
                else
                    addToInsnList(macro + mcMULTI);
           };
           if ((l5ilm28z == il3) ||
              (l5ilm28z == il1) &&
              (insnList@.st != st0))
               prepLoad;
           l5var23z.m  =  insnCopy.regsused | insnList@.regsused;
           if (not l5var25z) {
               if (insnCopy.ilf7 == 18) {
                    if (insnList@.ilm == il2) {
                        insnCopy.ilf7  =  15;
                    } else {
                        insnCopy.ilf7  =  16;
                        curInsnTemplate  =  insnTemp[WTC];
                        prepLoad;
                        curInsnTemplate  =  insnTemp[XTA];
                    };
                    insnCopy.next  =  insnList@.next;
                    insnCopy.next2  =  insnList@.next2;
                } else {
                    if (insnCopy.ilf7 >= 15) {
                        l5var1z  =   myminel(l5var22z.i);
                        if (0 >= l5var1z) {
                            l5var1z  =  myminel(freeRegs ~ insnCopy.regsused);
                            if (0 >= l5var1z)
                                l5var1z  =  9;
                        };
                        saved  =  insnList;
                        insnList  =  copyPtr;
                        l5var23z.m  =  l5var23z.m | [l5var1z];
                        if (insnCopy.ilf7 == 15) {
                            addToInsnList(insnTemp[ATI] + l5var1z);
                        } else {
                            addToInsnList(indexreg[l5var1z] + insnTemp[VTM]);
                        };
                        insnCopy.ilf7  =  l5var1z;
                        insnCopy.regsused  =  insnCopy.regsused | [l5var1z];
                        insnList  =  saved;
                    } else {
                            l5var1z  =  insnCopy.ilf7;
                    };
                    if (l5var1z IN insnList@.regsused) {
                         P4606;
                         insnList@.next@.next  =  insnCopy.next2;
                         insnCopy.next2  =  insnList@.next2;
                         insnList  =  copyPtr;
                         addInsnAndOffset(macro+mcADDSTK2REG, l5var1z);
                    } else {
                         if (insnList@.ilm == il2) {
                             addInsnAndOffset(macro+mcADDACC2REG, l5var1z);
                         } else {
                             curInsnTemplate  =  insnTemp[WTC];
                             prepLoad;
                             curInsnTemplate  =  insnTemp[XTA];
                             addToInsnList(indexreg[l5var1z] + insnTemp[UTM]);
                         };
                         insnCopy.next@.next  =  insnList@.next2;
                         insnCopy.next  =  insnList@.next;
                     }
                };
           } else {
                if (insnCopy.st == st0) {
                    prepLoad;
                    if (l5var7z != 0) {
                        curVal.i  =  0 - l5var7z;
                        if (not typeCheck(insnList@.typ, intType))
                            curVal.m  =  curVal.m ~ intZero;
                        addToInsnList(KADD+I8 + getFCSToffset);
                        insnList@.next@.mode  =  1;
                    };
                    l5var24z  =  0 in insnCopy.regsused;
                    if (l5var24z)
                        addToInsnList(macro + mcPUSH);
                    saved  =  insnList;
                    insnList  =  copyPtr;
                    setAddrTo(14);
                    if (l5var24z)
                        addToInsnList(macro + mcPOP);
                    l5var23z.m  =  l5var23z.m | [0, 10, 11, 13, 14];
                    insnCopy.st  =  st2;
                    insnCopy.ilf6  =  0;
                    insnCopy.ilf5.i  =  0;
                    insnCopy.width  =  insnCopy.typ@.pcksize;
                    curVal.i  =  insnCopy.width;
                    if (curVal.i == 24)
                        curVal.i  =  7;
                    curVal.i  =  curVal.i << 24;
                    addToInsnList(allocSymtab(  /* P/00C */
                        helperNames[76] | curVal.i)+(KVTM+I11));
                    insnCopy.ilf7  =  16;
                    insnCopy.shift  =  0;
                    saved@.next@.next  =  insnCopy.next2;
                    insnCopy.next2  =  saved@.next2;
                } else {
                    error(errUsingVarAfterIndexingPackedArray);
                }
            };
            insnCopy.regsused  =  l5var23z.m;
        };
        insnCopy.typ  =  l5var26z;
    };
    insnList  =  l5ins21z;
    insnList@  =  insnCopy;
}; /* genGetElt */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genEntry;
var
    l5exp1z, l5exp2z: eptr;
    l5idr3z, l5idr4z, l5idr5z, l5idr6z: irptr;
    l5bool7z, l5bool8z, l5bool9z, l5bool10z, l5bool11z: bool;
    l5var12z, l5var13z, l5var14z: word;
    l5var15z: int;
    l5var16z, l5var17z, l5var18z, l5var19z: word;
    l5inl20z: @insnltyp;
    l5op21z: operator; l5idc22z: idclass;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocGlobalObject(l6arg1z: irptr): int;
{
    if (l6arg1z@.pos == 0) {
        if (l6arg1z@.flags & [20, 21] != []) {
            curVal  =  l6arg1z@.id;
            curVal.m  =  makeNameWithStars(true);
            l6arg1z@.pos  =  allocExtSymbol(extSymMask);
        } else {
            l6arg1z@.pos  =  symTabPos;
            putToSymTab(0U);
        }
    };
    allocGlobalObject  =  l6arg1z@.pos;
}; /* allocGlobalObject */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void traceEntry(isEntry: bool);
{
    if (not (debugEntry in optSflags.m))
        exit;
    curVal  =  l5idr5z@.id;
    addToInsnList(KVTM+I10 + addCurValToFCST);
    if (isEntry)
        addToInsnList(KVTM+I11 + lineCnt);
    addToInsnList(getHelperProc(ord(isEntry) * 22 + 57)); /* P/C(E|I) */
}; /* traceEntry */
//
{ /* genEntry */
    l5exp1z  =  exprToGen@.expr1;
    l5idr5z  =  exprToGen@.id2;
    l5bool7z  =  (l5idr5z@.typ == NIL);
    l5bool9z  =  (l5idr5z@.list == NIL);
    if (l5bool7z)
        l5var13z.i  =  3 else l5var13z.i  =  4;
    l5var12z.m  =  l5idr5z@.flags;
    l5bool10z  =  (21 in l5var12z.m);
    l5bool11z  =  (24 in l5var12z.m);
    if (l5bool9z) {
        l5var14z.i  =  F3307(l5idr5z);
        l5idr6z  =  l5idr5z@.argList;
    } else {
        l5var13z.i  =  l5var13z.i + 2;
    };
    new(insnList);
    insnList@.next2  =  NIL;
    insnList@.next  =  NIL;
    insnList@.typ  =  l5idr5z@.typ;
    insnList@.regsused  =  (l5idr5z@.flags | [7:15]) & [0:8, 10:15];
    insnList@.ilm  =  il2;
    if (l5bool10z) {
        l5bool8z  =  not l5bool7z;
        if (checkFortran) {
            addToInsnList(getHelperProc(92)); /* "P/MF" */
        }
    } else {
        l5bool8z  =  true;
        if ((not l5bool9z) && (l5exp1z != NIL)
            || (l5bool9z) && (l5var14z.i >= 2)) {
            addToInsnList(KUTM+SP + l5var13z.i);
        };
    };
    l5var14z.i  =  0;
(loop)
    while (l5exp1z != NIL) {
        l5exp2z  =  l5exp1z@.expr2;
        l5exp1z  =  l5exp1z@.expr1;
        l5op21z  =  l5exp2z@.op;
        l5var14z.i  =  l5var14z.i + 1;
        l5inl20z  =  insnList;
        if ((l5op21z == PCALL) || (l5op21z == FCALL)) {
            l5idr4z  =  l5exp2z@.id2;
            new(insnList);
            insnList@.next2  =  NIL;
            insnList@.next  =  NIL;
            insnList@.regsused  =  [];
            set145z  =  set145z | l5idr4z@.flags;
            if (l5idr4z@.list != NIL) {
                addToInsnList(l5idr4z@.offset + insnTemp[XTA] +
                              l5idr4z@.value);
                if (l5bool10z)
                    addToInsnList(getHelperProc(19)); /* "P/EA" */
            } else
(a)         {
                if (l5idr4z@.value == 0) {
                    if ((l5bool10z) && (21 in l5idr4z@.flags)) {
                        addToInsnList(allocGlobalObject(l5idr4z) +
                                      (KVTM+I14));
                        addToInsnList(KITA+14);
                        exit a;
                    } else {
                        l5var16z.i  =  0;
                        formJump(l5var16z.i);
                        padToLeft;
                        l5idr4z@.value  =  moduleOffset;
                        l5idr3z  =  l5idr4z@.argList;
                        l5var15z  =  ord(l5idr4z@.typ != NIL);
                        l5var17z.i  =  F3307(l5idr4z);
                        form3Insn(KVTM+I10+ 4+moduleOffset,
                                  KVTM+I9 + l5var15z,
                                  KVTM+I8 + 074001);
                        formAndAlign(getHelperProc(62)); /* "P/BP" */
                        l5var15z  =  l5var17z.i + 2 + l5var15z;
                        form1Insn(KXTA+SP + l5var15z);
                        if ((1) < l5var17z.i)
                            form1Insn(KUTM+SP + l5var15z)
                        else
                            form1Insn(0);
                        form2Insn(
                            getHelperProc(63/*P/B6*/) + 06437777777300000U,
                            allocGlobalObject(l5idr4z) + KUJ);
                        if (l5idr3z != NIL) {
                            do {
                                l5idc22z  =  l5idr3z@.cl;
                                if ((l5idc22z == ROUTINEID) &&
                                   (l5idr3z@.typ != NIL))
                                    l5idc22z  =  ENUMID;
                                form2Insn(0, ord(l5idc22z));
                                l5idr3z  =  l5idr3z@.list;
                            } while (l5idr4z != l5idr3z);
                        };
                        storeObjWord(0U);
                        P0715(0, l5var16z.i);
                    }
                };
                addToInsnList(KVTM+I14 + l5idr4z@.value);
                if (21 in l5idr4z@.flags)
                    addToInsnList(KITA+14)
                else
                    addToInsnList(getHelperProc(64)); /* "P/PB" */
            };
            if (l5op21z == PCALL)
                l5idc22z  =  ROUTINEID
            else
                l5idc22z  =  ENUMID;
        } else {
            genFullExpr(l5exp2z);
            if (insnList@.ilm == il1)
                l5idc22z  =  FORMALID
            else
                l5idc22z  =  VARID;
        };
        if (not (not l5bool9z || (l5idc22z != FORMALID) ||
               (l5idr6z@.cl != VARID)))
            l5idc22z  =  VARID;
(loop)      if ((l5idc22z == FORMALID) || (l5bool11z)) {
            setAddrTo(14);
            addToInsnList(KITA+14);
        } else if (l5idc22z == VARID) {
            if (insnList@.typ@.size != 1) {
                l5idc22z  =  FORMALID;
                goto loop;
            } else {
                prepLoad;
            }
        };
        if (not l5bool8z)
            addxToInsnList(macro + mcPUSH);
        l5bool8z  =  false;
        if (l5inl20z@.next != NIL) {
            l5inl20z@.next@.next  =  insnList@.next2;
            insnList@.next2  =  l5inl20z@.next2;
        };
        insnList@.regsused  =  insnList@.regsused | l5inl20z@.regsused;
        if (not l5bool9z) {
            curVal.cl  =  l5idc22z;
            addToInsnList(KXTS+I8 + getFCSToffset);
        };
        if (l5bool9z && not l5bool11z)
            l5idr6z  =  l5idr6z@.list;
    }; /* while -> 7061 */
    traceEntry(true);
    if (l5bool10z) {
        addToInsnList(KNTR+2);
        insnList@.next@.mode  =  4;
    };
    if (l5bool9z) {
        addToInsnList(allocGlobalObject(l5idr5z) + (KVJM+I13));
        if (20 in l5idr5z@.flags) {
            l5var17z.i  =  1;
        } else {
            l5var17z.i  =  l5idr5z@.offset / 04000000;
        }
    } else {
        l5var15z  =  0;
        if (l5var14z.i == 0) {
            l5var17z.i  =  l5var13z.i + 1;
        } else {
            l5var17z.i  =  -(2 * l5var14z.i + l5var13z.i);
            l5var15z  =  1;
        };
        addInsnAndOffset(macro+16 + l5var15z,
                         getValueOrAllocSymtab(l5var17z.i));
        addToInsnList(l5idr5z@.offset + insnTemp[UTC] + l5idr5z@.value);
        addToInsnList(macro+18);
        l5var17z.i  =  1;
    };
    insnList@.next@.mode  =  2;
    if (curProcNesting != l5var17z.i) {
        if (not l5bool10z) {
            if (l5var17z.i + 1 == curProcNesting) {
                addToInsnList(KMTJ+I7 + curProcNesting);
            } else {
                l5var15z  =  frameRestore[curProcNesting][l5var17z.i];
                if (l5var15z == (0)) {
                    curVal.i  =  /*=A3*/'P/      ';/*=A2*/
                    l5var19z.i  =  (curProcNesting + 16) << 30;
                    l5var18z.i  =  (l5var17z.i + 16) << 24;
                    curVal.m  =  curVal.m | l5var19z.m | l5var18z.m;
                    l5var15z  =  allocExtSymbol(extSymMask);
                    frameRestore[curProcNesting][l5var17z.i]  =  l5var15z;
                };
                addToInsnList(KVJM+I13 + l5var15z);
            }
        }
    };
    if (not l5bool9z || ([20, 21] & l5var12z.m != [])) {
        addToInsnList(KVTM+040074001);
    };
    set145z  =  (set145z | l5var12z.m) & [1:15];
    traceEntry(false);
    if (l5bool10z) {
        if (not checkFortran)
            addToInsnList(KNTR+7)
        else
            addToInsnList(getHelperProc(93));    /* "P/FM" */
        insnList@.next@.mode  =  2;
    } else {
        if (not l5bool7z)
            addToInsnList(KXTA+SP + l5var13z.i - 1);
    };
    if (not l5bool7z) {
        insnList@.typ  =  l5idr5z@.typ;
        insnList@.regsused  =  insnList@.regsused | [0];
        insnList@.ilm  =  il2;
        set146z  =  set146z ~ l5var12z.m;
    }
}; /* genEntry */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void startInsnList(l5arg1z: ilmode);
{
    new(insnList);
    insnList@.next  =  NIL;
    insnList@.next2  =  NIL;
    insnList@.typ  =  exprToGen@.typ;
    insnList@.regsused  =  [];
    insnList@.ilm  =  l5arg1z;
    if (l5arg1z == ilCONST) {
        insnList@.ilf5.i  =  exprToGen@.num1;
        insnList@.ilf7  =  exprToGen@.num2;
    } else {
        insnList@.st  =  st0;
        insnList@.ilf7  =  18;
        insnList@.ilf5.i  =  curFrameRegTemplate;
        insnList@.ilf6  =  exprToGen@.num1;
    }
}; /* startInsnList */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genCopy;
var
    size: int;
{
    size  =  insnList@.typ@.size;
    if (size == 1) {
        saved  =  insnList;
        insnList  =  otherIns;
        prepLoad;
        genOneOp;
        insnList  =  saved;
        prepStore;
        genOneOp;
    } else {
        prepMultiWord;
        genOneOp;
        size  =  size - 1;
        formAndAlign(KVTM+I13 + getValueOrAllocSymtab(-size));
        work  =  moduleOffset;
        form2Insn(KUTC+I14 + size, KXTA+I13);
        form3Insn(KUTC+I12 + size, KATX+I13,
                  KVLM+I13 + work);
        set145z  =  set145z | [12:14];
    }
}; /* genCopy */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genConstDiv;
    function PASDIV(r: real): word;
        extern;
{
    curVal  =  PASDIV(1.0/arg2Val.i);
    addToInsnList(KMUL+I8 + getFCSToffset);
}; /* genConstDiv */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void genComparison;
label
    7475, 7504, 7514, 7530;
var
    hasEq: bool;
    l5set2z: int;
    mode, size: int;
{
    l3int3z  =  ord(curOP) - ord(NEOP);
    hasEq  =  odd(l3int3z);
    if (l3int3z == 6) {     /* IN */
        if (arg1Const) {
            if (arg2Const) {
                insnList@.ilf5.b  =  (arg1Val.i IN arg2Val.m);
            } else {
                l5set2z  =  [arg1Val.i];
                if (l5set2z == 0U) {
                    insnList@.ilf5.b  =  false;
                } else {
                    insnList  =  otherIns;
                    prepLoad;
                    curVal.i  =  l5set2z;
                    addToInsnList(KAAX+I8 + getFCSToffset);
                    insnList@.ilf5.i  =  0;
                    insnList@.ilm  =  il3;
                }
            };
        } else {
            saved  =  insnList;
            insnList  =  otherIns;
            otherIns  =  saved;
            nextInsn  =  66;      /* P/IN */
            genHelper;
            insnList@.ilm  =  il2;
        }
    } else {
        if (hasEq)
            l3int3z  =  l3int3z - 1;
        l2typ13z  =  insnList@.typ;
        curVarKind  =  l2typ13z@.k;
        size  =  l2typ13z@.size;
        if (l2typ13z == realType) {
            if (fuzzReals)
                work  =  0
            else
                work  =  1;
        } else if (curVarKind IN [kindScalar, kindRange])
            work  =  3
        else {
            work  =  4;
        };
        if (size != 1) {
            prepMultiWord;
            addInsnAndOffset(KVTM+I11, 1 - size);
            addToInsnList(getHelperProc(89 + l3int3z)); /* P/EQ */
            insnList@.ilm  =  il2;
            hasEq  =  not hasEq;
        } else if (l3int3z == 0) {
            if (work == 0) {
                nextInsn  =  15;         /* P/CP */
7475:           genHelper;
                insnList@.ilm  =  il2;
            } else {
                nextInsn  =  insnTemp[AEX];
                tryFlip(true);
7504:           insnList@.ilm  =  il3;
                insnList@.ilf5.i  =  0;
            };
        } else {
            switch (work) {
            0: {
                nextInsn  =  16;         /* P/AB */
                goto 7475;
            };
            1: {
                mode  =  3;
7514:           nextInsn  =  insnTemp[SUB];
                tryFlip(false);
                insnList@.next@.mode  =  mode;
                if (mode == 3) {
                    addToInsnList(KNTR+023);
                    insnList@.next@.mode  =  2;
                };
                goto 7504;
            };
            2: { // work == 2 unused
                nextInsn  =  insnTemp[AAX];
7530:           prepLoad;
                addToInsnList(KAEX+ALLONES);
                tryFlip(true);
                goto 7504;
            };
            3: {
                mode  =  1;
                goto 7514;
            };
            4: {
                nextInsn  =  insnTemp[ARX];
                goto 7530;
            };
            }; /* switch */
        };
        insnList@.regsused  =  insnList@.regsused ~ [16];
        if (hasEq)
             negateCond;
    };
}; /* genComparison */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* genFullExpr */;
    if (exprToGen == NIL)
        exit;
7567:
    curOP  =  exprToGen@.op;
    if (curOP < GETELT) {
        genFullExpr(exprToGen@.expr2);
        otherIns  =  insnList;
        if (curOP == ASSIGNOP)
            l3bool13z  =  false;
        genFullExpr(exprToGen@.expr1);
        if (curOP == ASSIGNOP)
            l3bool13z  =  true;
        if (insnList@.ilm == ilCONST) {
            arg1Const  =  true;
            arg1Val  =  insnList@.ilf5;
        } else
            arg1Const  =  false;
        if (otherIns@.ilm == ilCONST) {
            arg2Const  =  true;
            arg2Val  =  otherIns@.ilf5;
        } else
            arg2Const  =  false;
        if (curOP IN [NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP]) {
            genComparison;
        } else {
            if (arg1Const && arg2Const) {
                switch (curOP) {
                MUL:        arg1Val.r  =  arg1Val.r * arg2Val.r;
                RDIVOP:     arg1Val.r  =  arg1Val.r / arg2Val.r;
                AMPERS:     arg1Val.b  =  arg1Val.b && arg2Val.b;
                IDIVOP:     arg1Val.i  =  arg1Val.i / arg2Val.i;
                IMODOP:     arg1Val.i  =  arg1Val.i % arg2Val.i;
                PLUSOP:     arg1Val.r  =  arg1Val.r + arg2Val.r;
                MINUSOP:    arg1Val.r  =  arg1Val.r - arg2Val.r;
                OROP:       arg1Val.b  =  arg1Val.b || arg2Val.b:
                IMULOP:     arg1Val.i  =  arg1Val.i * arg2Val.i;
                SETAND:     arg1Val.m  =  arg1Val.m & arg2Val.m;
                SETXOR:     arg1Val.m  =  arg1Val.m ^ arg2Val.m;
                INTPLUS:    arg1Val.i  =  arg1Val.i + arg2Val.i;
                INTMINUS:   arg1Val.i  =  arg1Val.i - arg2Val.i;
                SETOR:      arg1Val.m  =  arg1Val.m | arg2Val.m;
                SETSUB:
                    goto 10075;
                NEOP, EQOP, LTOP, GEOP, GTOP, LEOP, INOP,
                SHLEFT, SHRIGHT,
                badop27, badop30, badop31, MKRANGE, ASSIGNOP:
                    error(200);
                }; /* switch 7750 */
                insnList@.ilf5  =  arg1Val;
            } else {
                l3int3z  =  opToMode[curOP];
                flags  =  opFlags[curOP];
                nextInsn  =  opToInsn[curOP];
                switch (flags) {
                opfCOMM:
7760:               tryFlip(curOP in [MUL, PLUSOP, SETAND, INTPLUS]);
                opfHELP:
                    genHelper;
                opfASSN: {
                    genCopy;
                    exit
                };
                opfAND: {
                    genBoolAnd;
                    exit
                };
                opfOR: {
                    negateCond;
                    saved  =  insnList;
                    insnList  =  otherIns;
                    negateCond;
                    otherIns  =  insnList;
                    insnList  =  saved;
                    genBoolAnd;
                    negateCond;
                    exit
                };
                opfMOD:
                    if (arg2Const) {
                        prepLoad;
                        if (card(arg2Val.m) == 4) {
                            curVal.m = intZero|[minel(arg2Val.m~intZero)+1..47];
                            addToInsnList(KAAX+I8 +getFCSToffset);
                            l3int3z  =  0;
                        } else {
                            addToInsnList(macro + mcPUSH);
                            genConstDiv;
                            insnList@.next@.mode  =  1;
                            curVal.m  =  arg2Val.m ~ [1, 3];
                            addToInsnList(KMUL+I8 + getFCSToffset);
                            addToInsnList(KYTA+64);
                            addToInsnList(KRSUB+SP);
                            l3int3z  =  1;
                        }
                    } else {
                        genHelper;
                    };
                opfDIV: {
                    if (arg2Const) {
                        prepLoad;
                        genConstDiv;
                        l3int3z  =  1;
                    } else
                        genHelper;
                };
                opfMULMSK: {
                    if (arg1Const) {
                        insnList@.ilf5.m  =  arg1Val.m ^ [1, 3];
                    } else {
                        if (arg2Const) {
                            otherIns@.ilf5.m  =  arg2Val.m ^ [1, 3];
                        } else {
                            prepLoad;
                            addToInsnList(KAEX+MULTMASK);
                        }
                    };
                    tryFlip(true);
                    insnList@.next@.mode  =  1;
                    if (fixMult)
                        addToInsnList(macro + mcMULTI)
                    else
                        addToInsnList(KYTA+64);
                };
                opfSHIFT: {
                    if (!arg2Const) error(200);
                    prepLoad;
                    if (curOP == SHRIGHT)
                        addToInsnList(ASN64+arg2Val.i)
                    else
                        addToInsnList(ASN64-arg2Val.i)
                 };
                opfINV: {
10075:              saved  =  insnList;
                    insnList  =  otherIns;
                    otherIns  =  saved;
                    prepLoad;
                    addToInsnList(KAEX+ALLONES);
                    goto 7760
                }
                }; /* switch 10122 */
10122:          insnList@.next@.mode  =  l3int3z;
            }
        }
    } else {
        if (FILEPTR >= curOP) {
            if (curOP == GETVAR) {
                new(insnList);
                curIdRec  =  exprToGen@.id1;
                with insnList@ do {
                    next  =  NIL;
                    next2  =  NIL;
                    regsused  =  [];
                    ilm  =  il1;
                    ilf5.i  =  curIdRec@.offset;
                    ilf6  =  curIdRec@.high.i;
                    st  =  st0;
                    ilf7  =  18;
                };
                if (curIdRec@.cl == FORMALID) {
                    genDeref;
                } else if (curIdRec@.cl == ROUTINEID) {
                    insnList@.ilf6  =  3;
                    insnList@.ilf5.i  =  (insnList@.ilf5.i + frameRegTemplate);
                } else if (insnList@.ilf6 >= 074000) {
                    addToInsnList(insnTemp[UTC] + insnList@.ilf6);
                    insnList@.ilf6  =  0;
                    insnList@.ilf7  =  17;
                    insnList@.ilf5.i  =  0;
                }
            } else if (curOP == GETFIELD) {
                genFullExpr(exprToGen@.expr1);
                curIdRec  =  exprToGen@.id2;
                with insnList@ do {
                    ilf6  =  ilf6 + curIdRec@.offset;
                    if (curIdRec@.pckfield) {
                        switch (st) {
                        st0:
                            shift  =  curIdRec@.shift;
                        st1: {
                            shift  =  shift + curIdRec@.shift;
                            if (not (S6 IN optSflags.m))
                                shift  =  shift +
                                           curIdRec@.uptype@.bits - 48;
                        };
                        st2:
                            if (not l3bool13z)
                                error(errUsingVarAfterIndexingPackedArray)
                            else {
                                P5155;
                                insnList@.shift  =  curIdRec@.shift;
                            }
                        };
                        insnList@.width  =  curIdRec@.width;
                        insnList@.st  =  st1;
                        insnList@.regsused  =  insnList@.regsused | [0];
                    }
                };
            } else if (curOP == GETELT)
                genGetElt
            else if ((curOP == DEREF) || (curOP == FILEPTR)) {
                genFullExpr(exprToGen@.expr1);
                genDeref;
            } else
            if (curOP == op36) {
                startInsnList(il1);
            } else
            if (curOP == op37) {
                startInsnList(il1);
                genDeref;
            } else
            if (curOP == GETENUM)
                startInsnList(ilCONST)
        } else if (curOP == ALNUM)
            genEntry
        else if (curOP IN [BOUNDS..RNEGOP]) {
            genFullExpr(exprToGen@.expr1);
            if (insnList@.ilm == ilCONST) {
                arg1Val  =  insnList@.ilf5;
                switch (curOP) {
                BOUNDS: {
                    arg2Val.m  =  [0,1,3] | arg1Val.m;
                    with exprToGen@.typ2@ do {
                        if ((arg2Val.i < left) ||
                           (right < arg2Val.i))
                            error(errNeedOtherTypesOfOperands)
                    }
                };
                TOREAL: arg1Val.r  =  arg1Val.i;
                NOTOP:  arg1Val.b  =  not arg1Val.b;
                RNEGOP: arg1Val.r  =  -arg1Val.r;
                INEGOP: arg1Val.i  =  -arg1Val.i;
                }; /* switch 10345 */
                insnList@.ilf5  =  arg1Val;
            } else if (curOP == NOTOP) {
                negateCond;
            } else {
                prepLoad;
                if (curOP == BOUNDS) {
                    if (checkBounds)
                        genCheckBounds(exprToGen@.typ2);
                } else if (curOP == TOREAL) {
                    addToInsnList(insnTemp[AVX]);
                    l3int3z  =  3;
                    goto 10122;
                } else {
                    addToInsnList(KAVX+MINUS1);
                    if (curOP == RNEGOP)
                        l3int3z  =  3
                    else
                        l3int3z  =  1;
                    goto 10122;
                }
            }
        } else if (curOP == STANDPROC) {
            genFullExpr(exprToGen@.expr1);
            work  =  exprToGen@.num2;
            if (100 < work) {
                prepLoad;
                addToInsnList(getHelperProc(work - 100));
            } else {
                if (insnList@.ilm == ilCONST) {
                    arg1Const  =  true;
                    arg1Val  =  insnList@.ilf5;
                } else
                    arg1Const  =  false;
                arg2Const  =  (insnList@.typ == realType);
                if (arg1Const) {
                    switch (work) {
                    fnSQRT:  arg1Val.r  =  sqrt(arg1Val.r);
                    fnSIN:   arg1Val.r  =  sin(arg1Val.r);
                    fnCOS:   arg1Val.r  =  cos(arg1Val.r);
                    fnATAN:  arg1Val.r  =  arctan(arg1Val.r);
                    fnASIN:  arg1Val.r  =  arcsin(arg1Val.r);
                    fnLN:    arg1Val.r  =  ln(arg1Val.r);
                    fnEXP:   arg1Val.r  =  exp(arg1Val.r);
                    fnABS:   arg1Val.r  =  abs(arg1Val.r);
                    fnTRUNC: arg1Val.i  =  trunc(arg1Val.r);
                    fnODD:   arg1Val.b  =  odd(arg1Val.i);
                    fnORD:   arg1Val.i  =  ord(arg1Val.c);
                    fnCHR:   arg1Val.c  =  chr(arg1Val.i);
                    fnSUCC:  arg1Val.c  =  succ(arg1Val.c);
                    fnPRED:  arg1Val.c  =  pred(arg1Val.c);
                    fnPTR:   arg1Val.c  =  chr(arg1Val.i);
                    fnROUND: arg1Val.i  =  round(arg1Val.r);
                    fnCARD:  arg1Val.i  =  card(arg1Val.m);
                    fnMINEL: arg1Val.i  =  minel(arg1Val.m);
                    fnABSI:  arg1Val.i  =  abs(arg1Val.i);
                    fnEOF,
                    fnREF,
                    fnEOLN:
                        error(201);
                    };
                    insnList@.ilf5  =  arg1Val;
                } else if ((work >= fnEOF) && (fnEOLN >= work)) {
                    if (work == fnREF) {
                        setAddrTo(14);
                        addToInsnList(KITA+14);
                    } else {
                        setAddrTo(12);
                        addToInsnList(getHelperProc(work - 6));
                    };
                    with insnList@ do {
                        ilm  =  il2;
                        regsused  =  regsused | [0];
                    }
                } else {
                    prepLoad;
                    if (work == fnTRUNC) {
                        l3int3z  =  2;
                        addToInsnList(getHelperProc(58)); /*"P/TR"*/
                        goto 10122;
                    };
                    if (work IN [fnSQRT:fnEXP,
                                 fnODD:fnSUCC, fnCARD, fnPTR]) {
                        l3int3z  =  0;
                    } else if (work == fnABS)
                        l3int3z  =  3
                    else {
                        l3int3z  =  1;
                    };
                    addToInsnList(funcInsn[work]);
                    goto 10122;
                }
            }
        } else {
            if (curOP == NOOP) {
                curVal  =  exprToGen@.val;
                if (curVal.i IN set146z) {
                    new(insnList);
                    with insnList@ do {
                        typ  =  exprToGen@.expr2@.typ;
                        next  =  NIL;
                        next2  =  ;
                        regsused  =  [];
                        ilm  =  il1;
                        ilf7  =  18;
                        ilf5.i  =  indexreg[curVal.i];
                        ilf6  =  0;
                        st  =  st0;
                    }
                } else {
                    curVal.i  =  14;
                    exprToGen@.val  =  curVal;
                    exprToGen  =  exprToGen@.expr2;
                    goto 7567;
                };
                exit
            } else {
                error(220);
            }
        };
    };
    insnList@.typ  =  exprToGen@.typ;
}; /* genFullExpr */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void formFileInit;
var l4exf1z: @extfilerec;
    l4var2z: tptr;
    l4var3z: irptr;
    l4int4z, l4int5z: int;
{
    if (S5 IN optSflags.m) {
        formAndAlign(KUJ+I13);
        exit
    };
    form2Insn(KITS+13, KATX+SP);
    while (curExpr != NIL) {
        l4exf1z  =  ptr(ord(curExpr@.typ));
        l4var3z  =  curExpr@.id2;
        l4int4z  =  l4var3z@.value;
        l4var2z  =  l4var3z@.typ@.base;
        l4int5z  =  l4var3z@.typ@.elsize;
        if (l4int4z < 074000) {
            form1Insn(getValueOrAllocSymtab(l4int4z) +
                      insnTemp[UTC] + I7);
            l4int4z  =  0;
        };
        form3Insn(KVTM+I12 + l4int4z, KVTM+I10 + fileBufSize,
                  KVTM+I9 + l4int5z);
        form1Insn(KVTM+I11 + l4var2z@.size);
        if (l4exf1z == NIL) {
            form1Insn(insnTemp[XTA]);
        } else {
            curVal.i  =  l4exf1z@.location;
            if (curVal.i == 512)
                curVal.i  =  l4exf1z@.offset;
            form1Insn(KXTA+I8 + getFCSToffset);
        };
        formAndAlign(getHelperProc(69)); /*"P/CO"*/
        curVal  =  l4var3z@.id;
        form2Insn(KXTA+I8+getFCSToffset, KATX+I12+26);
        if ((l4int5z != 0) &&
           typeCheck(l4var2z, intType))
            form2Insn(KXTA+ZERO, KATX+I12+25);
        curExpr  =  curExpr@.expr1;
    };
    form1Insn(getHelperProc(70)/*"P/IT"*/ + (-I13-0100000));
    padToLeft;
}; /* formFileInit */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* formOperator */
    l3bool13z  =  true;
    if ((errors && (l3arg1z != SETREG)) || (curExpr == NIL))
        exit;
    if (not (l3arg1z IN [gen3, gen6, gen9, gen14, gen16]))
        genFullExpr(curExpr);
    switch (l3arg1z) {
    gen7: genOneOp;
    SETREG: {
        with insnList@ do {
            l3int3z  =  insnCount;
            new(l3var5z);
            l3var5z@.expr1  =  expr63z;
            expr63z  =  l3var5z;
            l3var5z@.op  =  NOOP;
            switch (st) {
            st0: {
                if (l3int3z == 0) {
                    l3int2z  =  14;
                } else {
                    l3var10z.m  =  set148z & freeRegs;
                    if (l3var10z.m != []) {
                        l3int2z  =  minel(l3var10z.m);
                    } else {
                        l3int2z  =  14;
                    };
                    if (l3int3z != 1) {
                        setAddrTo(l3int2z);
                        addToInsnList(KITA + l3int2z);
                        P5117(op37);
                    } else if (l3int2z != 14) {
                        setAddrTo(l3int2z);
                        genOneOp;
                    };
                    l3var11z.m  =  [l3int2z] ~ [14];
                    set145z  =  set145z ~ l3var11z.m;
                    freeRegs  =  freeRegs ~ l3var11z.m;
                    set146z  =  set146z | l3var11z.m;
                };
                curVal.i  =  l3int2z;
                l3var5z@.val  =  curVal;
            };
            st1: {
                curVal.i  =  14;
                l3var5z@.val  =  curVal;
            };
            st2:
                error(errVarTooComplex);
            }; /* switch */
        }; /* with */
        l3var5z@.expr2  =  curExpr;
    }; /* SETREG */
    gen0: {
        prepLoad;
        if (insnCount > 1)
            P5117(op36)
    };
    STORE: {
        prepStore;
        genOneOp
    };
    gen3: {
        curInsnTemplate  =  curVal.i;
        formOperator(LOAD);
        curInsnTemplate  =  insnTemp[XTA];
    };
    SETREG9: {
        if (insnList@.st != st0)
            error(errVarTooComplex);
        setAddrTo(9);
        genOneOp;
    };
    gen6: {
        l3int1z  =  curVal.i;
        genFullExpr(curExpr);
        prepLoad;
        if (9 IN insnList@.regsused)
            error(errVarTooComplex);
        genOneOp;
        form1Insn(KATX+I9 + l3int1z);
    };
    gen8: {
        setAddrTo(12);
        genOneOp
    };
    gen9: {
        curVal.m  =  curVal.m | intZero;
        form1Insn(KXTA+I8 + getFCSToffset);
    };
    gen10: {
        prepLoad;
        addxToInsnList(macro + mcPUSH);
        genOneOp;
    };
    gen11, gen12: {
        setAddrTo(11);
        if (l3arg1z == gen12)
            addxToInsnList(macro + mcPUSH);
        genOneOp;
        set145z  =  set145z | [12];
    };
    FILEACCESS: {
        setAddrTo(12);
        genOneOp;
        formAndAlign(jumpTarget);
    };
    gen14:
        formFileInit;
    LOAD: {
        prepLoad;
        genOneOp
    };
    BRANCH:
        with insnList@ do {
            l3bool9z  =  jumpTarget == 0;
            l3int3z  =  jumpTarget;
            if (ilm == ilCONST) {
                if (ilf5.b) {
                    jumpTarget  =  0;
                } else {
                    if (l3bool9z) {
                        formJump(jumpTarget);
                    } else {
                        form1Insn(insnTemp[UJ] + jumpTarget);
                    }
                }
            } else {
                l3var8z.b  =  (16 in insnList@.regsused);
                if ((insnList@.ilm == il3) &&
                   (insnList@.ilf5.i != 0)) {
                    genOneOp;
                    if (l3var8z.b) {
                        if (l3bool9z)
                            formJump(l3int3z)
                        else
                            form1Insn(insnTemp[UJ] + l3int3z);
                        P0715(0, jumpTarget);
                        jumpTarget  =  l3int3z;
                    } else {
                        if (not l3bool9z) {
                            if (not putLeft)
                                padToLeft;
                            P0715(l3int3z, jumpTarget);
                        }
                    };
                } else {
                    if (insnList@.ilm == il1) {
                        bool49z  =  false;
                        prepLoad;
                        bool49z  =  true;
                    };
                    genOneOp;
                    if (l3var8z.b)
                        nextInsn  =  insnTemp[U1A]
                    else
                        nextInsn  =  insnTemp[UZA];
                    if (l3bool9z) {
                        jumpType  =  nextInsn;
                        formJump(l3int3z);
                        jumpType  =  insnTemp[UJ];
                        jumpTarget  =  l3int3z;
                    } else {
                        form1Insn(nextInsn + l3int3z);
                    }
                }
            }
        }; /* BRANCH */
    gen16: {
        l3var5z  =  curExpr;
        curExpr  =  curExpr@.expr1;
        formOperator(gen11);
        genFullExpr(l3var5z@.expr2);
        if (11 IN insnList@.regsused)
            error(44); /* errIncorrectUsageOfStandProcOrFunc */
        setAddrTo(12);
        genOneOp;
        arg1Type  =  l3var5z@.expr2@.typ;
        with arg1Type@.range@ do
            l3int3z  =  right - left + 1;
        form2Insn((KVTM+I14) + l3int3z,
                  (KVTM+I10+64) - arg1Type@.pcksize);
        l3int3z  =  ord(l3var5z@.typ);
        l3int1z  =  arg1Type@.perword;
        if (l3int3z == 72)           /* P/KC */
            l3int1z  =  1 - l3int1z;
        form1Insn(getValueOrAllocSymtab(l3int1z) + (KVTM+I9));
        if (typeCheck(curExpr@.typ, intType)) {
            l3int1z  =  KXTA+ZERO;
        } else {
            l3int1z  =  insnTemp[XTA];
        };
        form1Insn(l3int1z);
        formAndAlign(getHelperProc(l3int3z));
   };
   LITINSN: {
        with insnList@ do {
            if (ilm != ilCONST)
                error(errNoConstant);
            if (insnList@.typ@.size != 1)
                error(errConstOfOtherTypeNeeded);
            curVal  =  insnList@.ilf5;
        }
    };
    }; /* switch */
}; /* formOperator */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseTypeRef(var newtype: tptr; skipTarget: setofsys);
label
    12247, 12366, 12476, 12760, 13020;
type
    pair = struct {
            first, second: int
    };
    pair7 = array [1..7] of pair;
    caserec = struct {
            size, count: int;
            pairs: pair7;
    };
var
    isPacked: bool;
    cond: bool;
    cases: caserec;
    leftBound, rightBound: word;
    numBits, l3int22z, span: int;
    curEnum, curField: irptr;
    l3typ26z, nestedType, tempType, curType: tptr;
    l3unu30z: word;
    l3idr31z: irptr;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void definePtrType(toType: tptr);
{
    new(curType = 4);
    curType@  =  [1, 15, kindPtr, toType];
    new(curEnum = 5);
    curEnum@  =  [curIdent, lineCnt, typelist, curType, TYPEID];
    typelist  =  curEnum;
}; /* definePtrType */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseRecordDecl(rectype: tptr; isOuterDecl: bool);
var
    l4typ1z, selType, l4var3z, l4var4z, l4var5z: tptr;
    l4var6z: irptr;
    l4var7z, l4var8z: word;
    l4var9z: int;
    cases1, cases2: caserec;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void addFieldToHash;
{
    curEnum@  =  [curIdent, , typeHashTabBase[bucket], ,
                    FIELDID, NIL, curType, isPacked];
    typeHashTabBase[bucket]  =  curEnum;
}; /* addFieldToHash */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void packFields;
label
    11523, 11622;
var
    l5var1z, pairIdx, l5var3z, l5var4z, l5var5z: int;
    l5var6z: @pair;
{
    parseTypeRef(selType, skipTarget | [SWITCHSY]);
    if (curType@.ptr2 == NIL) {
        curType@.ptr2  =  curField;
    } else {
        l3idr31z@.list  =  curField;
    };
    cond  =  isFileType(selType);
    if ((not isOuterDecl) && cond)
        error(errTypeMustNotBeFile);
    curType@.flag  =  cond || curType@.flag;
    l3idr31z  =  curEnum;
    do {
        curField@.typ  =  selType;
        if (isPacked) {
            l5var1z  =  selType@.bits;
            curField@.width  =  l5var1z;
            if (l5var1z != 48) {
                for pairIdx to cases.count do
11523:          {
                    l5var6z  =  ref(cases.pairs[pairIdx]);
                    if (l5var6z@.first >= l5var1z) {
                        curField@.shift  =  48 - l5var6z@.first;
                        curField@.offset  =  l5var6z@.second;
                        if (not (S6 IN optSflags.m))
                            curField@.shift  =  48 - curField@.width -
                                                  curField@.shift;
                        l5var6z@.first  =  l5var6z@.first - l5var1z;
                        if (l5var6z@.first == 0) {
                            cases.pairs[pairIdx]  =
                                cases.pairs[cases.count];
                            cases.count  =  cases.count - 1;
                        };
                        goto 11622;
                    }
                };
                if (cases.count != 7) {
                    cases.count  =  cases.count + 1;
                    pairIdx  =  cases.count;
                } else {
                    l5var3z  =  48;
                    for l5var4z to 7 do {
                        l5var5z  =  cases.pairs[l5var4z].first;
                        if (l5var5z < l5var3z) {
                            l5var3z  =  l5var5z;
                            pairIdx  =  l5var4z;
                        }
                    }; /* for */
                };
                cases.pairs[pairIdx]  =  [48, cases.size];
                cases.size  =  cases.size + 1;
                goto 11523;
            }
        };
        curField@.pckfield  =  false;
        curField@.offset  =  cases.size;
        cases.size  =  cases.size + selType@.size;
11622:
        if (PASINFOR.listMode == 3) {
            write(' ':16);
            if (curField@.pckfield)
                write('PACKED');
            write(' FIELD ');
            printTextWord(curField@.id);
            write('.OFFSET=', curField@.offset:5 oct, 'B');
            if (curField@.pckfield) {
                write('.<<=SHIFT=', curField@.shift:2,
                      '. WIDTH=', curField@.width:2, ' BITS');
            } else {
                write('.WORDS=', selType@.size:0);
            };
            writeLN;
        };
        cond  =  (curField == curEnum);
        curField  =  curField@.list;
    } while (not cond);
}; /* packFields */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* parseRecordDecl */
    if (SY != BEGINSY)
        requiredSymErr(BEGINSY);
    int93z  =  3;
    inSymbol;
    while (SY == IDENT) {
        l4var6z  =  NIL;
        do {
            if (SY != IDENT) {
                error(errNoIdent);
            } else {
                if (hashTravPtr != NIL)
                    error(errIdentAlreadyDefined);
                new(curEnum = 10);
                addFieldToHash;
                if (l4var6z == NIL) {
                    curField  =  curEnum;
                } else {
                    l4var6z@.list  =  curEnum;
                };
                l4var6z  =  curEnum;
                int93z  =  3;
                inSymbol;
            };
            cond  =  (SY != COMMA);
            if (not cond) {
                int93z  =  3;
                inSymbol;
            }
        } while (not cond);
        checkSymAndRead(COLON);
        packFields;
        if (SY == SEMICOLON) {
            int93z  =  3;
            inSymbol;
        }
    };
    if (SY == SWITCHSY) {
        int93z  =  3;
        inSymbol;
        selType  =  intType;
(identif)
        if (SY != IDENT) {
            error(3);
            skip(skipTarget | [OFSY]);
        } else {
            l4var8z  =  curIdent;
            l4var9z  =  bucket;
            curEnum  =  hashTravPtr;
            inSymbol;
            if (SY == COLON) {
                if (curEnum != NIL)
                    error(errIdentAlreadyDefined);
                new(curEnum = 10);
                curIdent  =  l4var8z;
                bucket  =  l4var9z;
                addFieldToHash;
                inSymbol;
                curField  =  curEnum;
                packFields;
            } else {
                curEnum  =  symHashTabBase[l4var9z];
                while (curEnum != NIL) {
                    if (curEnum@.id != l4var8z) {
                        curEnum  =  curEnum@.next;
                    } else {
                        if (curEnum@.cl != TYPEID) {
                            error(errNotAType);
                            selType  =  intType;
                        } else {
                            selType  =  curEnum@.typ;
                        };
                        exit identif;
                    };
                };
                error(errNotDefined)
            };
        };
        if (selType@.k == kindRange)
            selType  =  selType@.base;
        checkSymAndRead(OFSY);
        cases1  =  cases;
        cases2  =  cases;
        l4typ1z  =  NIL;
        do {
            l4var3z  =  NIL;
            do {
                parseLiteral(l4var4z, l4var7z, false);
                if (l4var4z == NIL)
                    error(errNoConstant)
                else if (not typeCheck(l4var4z, selType))
                    error(errConstOfOtherTypeNeeded);
                new(l4var5z = 7);
                l4var5z@  =  [cases.size, 48, kindCases,
                                    l4var7z, NIL, NIL, NIL];
                if (l4var3z == NIL) {
                    tempType  =  l4var5z;
                } else {
                    l4var3z@.r6  =  l4var5z;
                };
                l4var3z  =  l4var5z;
                inSymbol;
                cond  =  (SY != COMMA);
                if (not cond)
                    inSymbol;
            } while (not cond);
            if (l4typ1z == NIL) {
                if (curType@.base == NIL) {
                    curType@.base  =  tempType;
                } else {
                    rectype@.first  =  tempType;
                }
            } else {
                l4typ1z@.next  =  tempType;
            };
            l4typ1z  =  tempType;
            checkSymAndRead(COLON);
            parseRecordDecl(tempType, false);
            if ((cases2.size < cases.size) ||
               isPacked && (cases.size == 1) && (cases2.size == 1) &&
                (cases.count == 1) && (cases2.count == 1) &&
                (cases.pairs[1].first < cases2.pairs[1].first)) {
                cases2  =  cases;
            };
            cases  =  cases1;
            cond  =  SY != SEMICOLON;
            if (not cond)
                inSymbol;
            if (SY == ENDSY)
                cond  =  true;
        } while (not cond);
        cases  =  cases2;
    };
    rectype@.size  =  cases.size;
    if (isPacked && (cases.size == 1) && (cases.count == 1)) {
        rectype@.bits  =  48 - cases.pairs[1].first;
    };
    checkSymAndRead(ENDSY);
}; /* parseRecordDecl*/
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* parseTypeRef */
    isPacked  =  false;
12247:
    if (SY == ENUMSY) {
        inSymbol;
        checkSymAndRead(BEGINSY);
        span  =  0;
        int93z  =  0;
        curField  =  NIL;
        new(curType = 6);
        while (SY == IDENT) {
            if (isDefined)
                error(errIdentAlreadyDefined);
            new(curEnum = 7);
            curEnum@  =  [curIdent, curFrameRegTemplate,
                            symHashTabBase[bucket], curType,
                            ENUMID, NIL, ptr(span)];
            symHashTabBase[bucket]  =  curEnum;
            span  =  span + 1;
            if (curField == NIL) {
                curType@.enums  =  curEnum;
            } else {
                curField@.list  =  curEnum;
            };
            curField  =  curEnum;
            inSymbol;
            if (SY == COMMA) {
                int93z  =  0;
                inSymbol;
            } else {
                if (SY != ENDSY)
                    requiredSymErr(ENDSY);
            };
        };
        checkSymAndRead(ENDSY);
        if (curField == NIL) {
            curType  =  boolType;
            error(errNoIdent);
        } else {
            curType@  =  [1, nrOfBits(span - 1), kindScalar, ,
                          span, 0];
        };
    } else if (SY == ARROW) {
        inSymbol;
        if (SY != IDENT) {
            error(errNoIdent);
            curType  =  pointerType;
        } else {
            if (hashTravPtr == NIL) {
                if (inTypeDef) {
                    if (knownInType(curEnum)) {
                        curType  =  curEnum@.typ;
                    } else {
                        definePtrType(intType);
                    };
                } else {
12366:              error(errNotAType);
                    curType  =  pointerType;
                };
            } else {
                if (hashTravPtr@.cl != TYPEID) {
                    goto 12366
                };
                new(curType = 4);
                with curType@ do {
                    size  =  1;
                    bits  =  15;
                    k  =  kindPtr;
                    base  =  hashTravPtr@.typ;
                }
            };
            inSymbol;
        }
    } else if (SY == IDENT) {
        if (hashTravPtr != NIL) {
            if (hashTravPtr@.cl == TYPEID) {
                curType  =  hashTravPtr@.typ;
            } else {
                goto 12760;
            }
        } else {
            if (inTypeDef) {
                if (knownInType(curEnum)) {
                    curType  =  curEnum@.typ;
                    curType@.base  =  boolType;
                } else {
                    definePtrType(boolType);
                };
            } else {
                error(errNotAType);
                curType  =  intType;
            };
        };
        inSymbol;
    } else {
        if (SY == PACKEDSY) {
            isPacked  =  true;
            inSymbol;
            goto 12247;
        };
        if (SY == STRUCTSY) {
            new(curType = 7);
            typ121z  =  curType;
            with curType@ do {
                size  =  0;
                bits  =  48;
                k  =  kindStruct;
                ptr1  =  NIL;
                first  =  NIL;
                flag  =  false;
                pckrec  =  isPacked;
            };
            cases.size  =  0;
            cases.count  =  0;
            inSymbol;
            parseRecordDecl(curType, true);
        } else if (SY == ARRAYSY) {
            inSymbol;
            if (SY == LBRACK)
                inSymbol;
            tempType  =  NIL;
12476:      parseTypeRef(nestedType, skipTarget | [OFSY]);
            curVarKind  =  nestedType@.k;
            if (curVarKind != kindRange) {
                if ((curVarKind == kindScalar) &&
                   (nestedType != intType)) {
                    span  =  nestedType@.numen;
                } else {
                    error(8); /* errNotAnIndexType */
                    nestedType  =  intType;
                    span  =  10;
                };
                defineRange(nestedType, 0, span - 1);
            };
            new(l3typ26z, kindArray);
            with l3typ26z@ do {
                size  =  ord(tempType);
                bits  =  48;
                k  =  kindArray;
                range  =  nestedType;
            };
            if (tempType == NIL)
                curType  =  l3typ26z
            else
                tempType@.base  =  l3typ26z;
            tempType  =  l3typ26z;
            if (SY == COMMA) {
                inSymbol;
                goto 12476;
            };
            if (SY == RBRACK)
                inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(nestedType, skipTarget);
            l3typ26z@.base  =  nestedType;
            if (isFileType(nestedType))
                error(errTypeMustNotBeFile);
            do with l3typ26z@, ptr2@ do {
                span  =  high.i - low + 1;
                tempType  =  ptr(size);
                l3int22z  =  base@.bits;
                if (24 < l3int22z)
                    isPacked  =  false;
                bits  =  48;
                if (isPacked) {
                    l3int22z  =  48 / l3int22z;
                    if (l3int22z == 9) {
                        l3int22z  =  8;
                    } else if (l3int22z == 5) {
                        l3int22z  =  4
                    };
                    perword  =  l3int22z;
                    pcksize  =  48 / l3int22z;
                    l3int22z  =  span * pcksize;
                    if (l3int22z % 48 == 0)
                        numBits  =  0
                    else
                        numBits  =  1;
                    size  =  l3int22z / 48 + numBits;
                    if (size == 1)
                        bits  =  l3int22z;
                } else {
                    size  =  span * base@.size;
                    curVal.i  =  base@.size;
                    curVal.m  =  curVal.m & [7:47] | [0];
                    if (range@.base != intType)
                        curVal.m  =  curVal.m | [1, 3];
                    l3typ26z@.perword  =  KMUL+ I8 + getFCSToffset;
                };
                l3typ26z@.pck  =  isPacked;
                isPacked  =  false;
                cond  =  (curType == l3typ26z);
                l3typ26z  =  tempType;
            } while (not cond);
        } else if (SY == FILESY) {
            inSymbol;
            checkSymAndRead(OFSY);
            parseTypeRef(nestedType, skipTarget);
            if (isFileType(nestedType))
                error(errTypeMustNotBeFile);
            if (isPacked) {
                l3int22z  =  nestedType@.bits;
                if (24 < l3int22z)
                    isPacked  =  false;
            };
            new(curType, kindFile);
            if (not isPacked)
                l3int22z  =  0;
            with curType@ do {
                size  =  30;
                bits  =  48;
                k  =  kindFile;
                base  =  nestedType;
                elsize  =  l3int22z;
            }
        } else {
12760:      ;
            parseLiteral(tempType, leftBound, true);
            if (tempType != NIL) {
                inSymbol;
                if (SY != COLON) {
                    requiredSymErr(COLON);
                } else {
                    inSymbol;
                };
                parseLiteral(curType, rightBound, true);
                if ((curType == tempType) &&
                   (curType@.k == kindScalar)) {
                    defineRange(curType, leftBound.i, rightBound.i);
                    inSymbol;
                    goto 13020;
                }
            };
            error(64); /* errIncorrectRangeDefinition */
            curType  =  boolType;
        };
    };
13020:
    if (errors)
        skip(skipToSet | [RPAREN, RBRACK, SEMICOLON, OFSY]);
    newtype  =  curType;
}; /* parseTypeRef */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void dumpEnumNames(l3arg1z: tptr);
var
    l3var1z: irptr;
{
    if (l3arg1z@.start == 0) {
        l3arg1z@.start  =  FcstCnt;
        l3var1z  =  l3arg1z@.enums;
        while (l3var1z != NIL) {
            curVal  =  l3var1z@.id;
            l3var1z  =  l3var1z@.list;
            toFCST;
        }
    }
}; /* dumpEnumNames */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void formPMD;
var
    l3typ1z: tptr;
    l3var2z: word;
    l3var3z: int;
    l3var4z: bool;
    l3var5z: kind;
{
    for l3var4z  =  false to true do {
        if (l3var4z) {
            optSflags.i  =  optSflags.i | [S3];
            curVal.i  =  074001;
            P0715(2, 34); /*"P/DS"*/
            curVal  =  l2idr2z@.id;
            toFCST;
            curVal.i  =  lineCnt;
            toFCST;
        };
        for jj  =  0 to 127 do {
            curIdRec  =  symHashTabBase[jj];
            while ((curIdRec != NIL) &&
                  (l2idr2z < curIdRec)) with curIdRec@ do {
                l3var2z.i  =  typ@.size;
                if ((cl IN [VARID, FORMALID]) &&
                  (value < 074000)) {
                    curVal  =  id;
                    if (l3var4z)
                        toFCST;
                    l3typ1z  =  typ;
                    l3var5z  =  l3typ1z@.k;
                    l3var3z  =  [];
                    if (l3var5z == kindPtr) {
                        l3typ1z  =  l3typ1z@.base;
                        l3var5z  =  l3typ1z@.k;
                        l3var3z  =  [0];
                    };
                    if (l3typ1z == realType)
                        curVal.i  =  0
                    else if (typeCheck(l3typ1z, intType))
                        curVal.i  =  0100000
                    else if (typeCheck(l3typ1z, charType))
                        curVal.i  =  0200000
                    else if (l3var5z == kindArray)
                        curVal.i  =  0400000
                    else if (l3var5z == kindScalar) {
                        dumpEnumNames(l3typ1z);
                        curVal.i  =  01000000 * l3typ1z@.start + 0300000;
                    } else if (l3var5z == kindFile)
                        curVal.i  =  0600000
                    else {
                        curVal.i  =  0500000;
                    };
                    curVal.i  =  curVal.i + curIdRec@.value;
                    l3var2z  =  l3var2z << 33;
                    curVal.m  =  curVal.m & [15:47] | l3var2z.m | l3var3z;
                    if (l3var4z)
                        toFCST;
                };
                curIdRec  =  curIdRec@.next;
            };
        };
        curVal.m  =  [];
        if (l3var4z)
            toFCST;
    }
}; /* formPMD */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseDecls(l3arg1z: int);
var
    l3int1z: int;
    frame:   word;
    l3var3z: bool;
{
    switch (l3arg1z) {
    0: {
        int93z  =  0;
        inSymbol;
        if (SY != IDENT)
            errAndSkip(3, skipToSet | [IDENT]);
    };
    1: {
        prevErrPos  =  0;
        write('IDENT ');
        printTextWord(l2var12z);
        write(' IN LINE ', curIdRec@.offset:0);
    };
    2: {
        padToLeft;
        l3var3z  =  22 IN l2idr2z@.flags;
        l3arg1z  =  l2idr2z@.pos;
        frame.i  =  moduleOffset - 040000;
        if (l3arg1z != 0)
            symTab[l3arg1z]  =  [24, 29] | frame.m & halfWord;
        l2idr2z@.pos  =  moduleOffset;
        l3arg1z  =  F3307(l2idr2z);
        if (l3var3z) {
            if (41 >= entryPtCnt) {
                curVal  =  l2idr2z@.id;
                entryPtTable[entryPtCnt].m  =  makeNameWithStars(true);
                entryPtTable[entryPtCnt+1].m  =  [1] | frame.m ~ [0, 3];
                entryPtCnt  =  entryPtCnt + 2;
            } else
                error(87); /* errTooManyEntryProcs */
        };
        if (l2idr2z@.typ == NIL) {
            frame.i  =  3;
        } else {
            frame.i  =  4;
        };
        if (l3var3z)
            form2Insn((KVTM+I14) + l3arg1z + (frame.i - 3) * 01000,
                      getHelperProc(94 /*"P/NN"*/) - 010000000);
        if (1 < l3arg1z) {
            frame.i  =  getValueOrAllocSymtab(-(frame.i+l3arg1z));
        };
        if ((S5 IN optSflags.m) &&
           (curProcNesting == 1))
            l3int1z  =  59  /* P/LV */
        else
            l3int1z  =  curProcNesting;
        l3int1z  =  getHelperProc(l3int1z) - (-04000000);
        if (l3arg1z == 1) {
            form1Insn((KATX+SP) + frame.i);
        } else if (l3arg1z != 0) {
            form2Insn(KATX+SP, (KUTM+SP) + frame.i);
        };
        formAndAlign(l3int1z);
        savedObjIdx  =  objBufIdx;
        if (curProcNesting != 1)
            form1Insn(0);
        if (l3var3z)
            form1Insn(KVTM+I8+074001);
        if (l2int11z != 0) {
            form1Insn(insnTemp[XTA]);
            formAndAlign(KVJM+I13 + l2int11z);
            curVal.i  =  l2int11z;
            P0715(2, 49 /* "P/RDC" */);
        };
        if (curProcNesting == 1) {
            if ((heapCallsCnt != 0) &&
               (heapSize == 0))
                error(65 /*errCannotHaveK0AndNew*/);
            l3var3z  =  (heapSize == 0) ||
                (heapCallsCnt == 0) && (heapSize == 100);
            if (heapSize == 100)
                heapSize  =  4;
            if (not l3var3z) {
                form2Insn(KVTM+I14+getValueOrAllocSymtab(heapSize*02000),
                          getHelperProc(26 /*"P/GD"*/));
                padToLeft;
            }
        };
        if (doPMD)
            formPMD;
    }
    }; /* switch */
}; /* parseDecls */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void statement;
label
    8888;
var
    boundary: eptr;
    l3var2z: @numLabel;
    l3var3z: @strLabel;
    l3var4z: bool;
    l3bool5z: bool;
    l3var6z: idclass;
    curOffset: int;
    startLine: int;
    ifWhlTarget, elseJump: word;
    whileExpr: eptr;
    l3idr12z: irptr;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function isCharArray(arg: tptr): bool;
{
    with arg@ do
        isCharArray  =  (k == kindArray) && (base == charType);
}; /* isCharArray */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void expression;
    forward;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseLval;
label
    13462, 13530;
var
    l4exp1z, l4exp2z: eptr;
    l4typ3z: tptr;
    l4var4z: kind;
{
    if (hashTravPtr@.cl == FIELDID) {
        curExpr  =  expr62z;
        goto 13530;
    } else {
        new(curExpr);
        with curExpr@ do {
            typ  =  hashTravPtr@.typ;
            op  =  GETVAR;
            id1  =  hashTravPtr;
        };
13462:  inSymbol;
        l4typ3z  =  curExpr@.typ;
        l4var4z  =  l4typ3z@.k;
        if (SY == ARROW) {
            new(l4exp1z);
            with l4exp1z@ do {
                expr1  =  curExpr;
                if (l4var4z == kindPtr) {
                    typ  =  l4typ3z@.base;
                    op  =  DEREF;
                } else if (l4var4z == kindFile) {
                    typ  =  l4typ3z@.base;
                    op  =  FILEPTR;
                } else {
                    stmtName  =  '  ^   ';
                    error(errWrongVarTypeBefore);
                    l4exp1z@.typ  =  l4typ3z;
                }
            };
            curExpr  =  l4exp1z;
        } else if (SY == PERIOD) {
            if (l4var4z == kindStruct) {
                int93z  =  3;
                typ121z  =  l4typ3z;
                inSymbol;
                if (hashTravPtr == NIL) {
                    error(20); /* errDigitGreaterThan7 ??? */
                } else 13530: {
                    new(l4exp1z);
                    with l4exp1z@ do {
                        typ  =  hashTravPtr@.typ;
                        op  =  GETFIELD;
                        expr1  =  curExpr;
                        id2  =  hashTravPtr;
                    };
                    curExpr  =  l4exp1z;
                }
            } else {
                stmtName  =  '  .   ';
                error(errWrongVarTypeBefore);
            };
        } else if (SY == LBRACK) {
            stmtName  =  '  [   ';
            do {
                l4exp1z  =  curExpr;
                expression;
                l4typ3z  =  l4exp1z@.typ;
                if (l4typ3z@.k != kindArray) {
                    error(errWrongVarTypeBefore);
                } else {
                    if (not typeCheck(l4typ3z@.range, curExpr@.typ))
                        error(66 /*errOtherIndexTypeNeeded */);
                    new(l4exp2z);
                    with l4exp2z@ do {
                        typ  =  l4typ3z@.base;
                        expr1  =  l4exp1z;
                        expr2  =  curExpr;
                        op  =  GETELT;
                    };
                    l4exp1z  =  l4exp2z;
                };
                curExpr  =  l4exp1z;
                stmtName  =  '  ,   ';
            } while (SY == COMMA);
            if (SY != RBRACK)
                error(67 /*errNeedBracketAfterIndices*/);
        } else exit;
    };
    goto 13462;
}; /* parseLval */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void castToReal(var value: eptr);
var
    cast: eptr;
{
    new(cast);
    with cast@ do {
        typ  =  realType;
        op  =  TOREAL;
        expr1  =  value;
        value  =  cast;
    }
}; /* castToReal */
//
function areTypesCompatible(var l4arg1z: eptr): bool;
{
    if (arg1Type == realType) {
        if (typeCheck(intType, arg2Type)) {
            castToReal(l4arg1z);
            areTypesCompatible  =  true;
            exit
        };
    } else if ((arg2Type == realType) &&
               typeCheck(intType, arg1Type)) {
        castToReal(curExpr);
        areTypesCompatible  =  true;
        exit
    };
    areTypesCompatible  =  false;
}; /* areTypesCompatible */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseCallArgs(l4arg1z: irptr);
label
    13736;
var
    l4var1z: bool;
    l4exp2z, l4exp3z, l4exp4z: eptr;
    l4idr5z: irptr;
    l4op6z: operator;
    l4idc7z: idclass;
{
    with l4arg1z@ do {
        if (typ != NIL)
            set146z  =  set146z ~ flags;
        l4var1z  =  (list == NIL) && not (24 in flags);
    };
    new(l4exp3z);
    l4exp4z  =  l4exp3z;
    bool48z  =  true;
    with l4exp3z@ do {
        typ  =  l4arg1z@.typ;
        op  =  ALNUM;
        id2  =  l4arg1z;
        id1  =  NIL;
    };
    if (SY == LPAREN) {
        if (l4var1z) {
            l4idr5z  =  l4arg1z@.argList;
            if (l4idr5z == NIL) {
                error(errTooManyArguments);
                goto 8888;
            }
        };
        do {
            if ((l4var1z) && (l4arg1z == l4idr5z)) {
                error(errTooManyArguments);
                goto 8888;
            };
            bool47z  =  true;
            expression;
            l4op6z  =  curExpr@.op;
(a)         if (l4var1z) {
                l4idc7z  =  l4idr5z@.cl;
                if (l4op6z == PCALL) {
                    if ((l4idc7z != ROUTINEID) ||
                       (l4idr5z@.typ != NIL)) {
13736:                  error(39); /*errIncompatibleArgumentKinds*/
                        exit a
                    }
                } else {
                    if (l4op6z == FCALL) {
                        if (l4idc7z == ROUTINEID) {
                            if (l4idr5z@.typ == NIL)
                                goto 13736
                        } else if ((curExpr@.id2@.argList == NIL) &&
                           (l4idc7z == VARID)) {
                            curExpr@.op  =  ALNUM;
                            curExpr@.expr1  =  NIL;
                        } else
                            goto 13736;
                    } else if (l4op6z IN lvalOpSet) {
                        if ((l4idc7z != VARID) &&
                           (l4idc7z != FORMALID))
                            goto 13736;
                    } else {
                        if (l4idc7z != VARID)
                            goto 13736;
                    }
                };
                arg1Type  =  curExpr@.typ;
                if (arg1Type != NIL) {
                    if (!typeCheck(arg1Type, l4idr5z@.typ))
                        error(40); /*errIncompatibleArgumentTypes*/
                }
            };
            new(l4exp2z);
            with l4exp2z@ do {
                typ  =  NIL;
                expr1  =  NIL;
                expr2  =  curExpr;
            };
            l4exp4z@.expr1  =  l4exp2z;
            l4exp4z  =  l4exp2z;
            if (l4var1z)
                l4idr5z  =  l4idr5z@.list;
        } while (SY == COMMA);
        if ((SY != RPAREN) ||
           l4var1z && (l4idr5z != l4arg1z))
            error(errNoCommaOrParenOrTooFewArgs)
        else
            inSymbol;
    } else {
        if ((l4var1z) && (l4arg1z@.argList != NIL))
            error(42); /*errNoArgList*/
    };
    curExpr  =  l4exp3z;
}; /* parseCallArgs */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void factor;
label
    14567;
var
    l4var1z: word;
    l4var2z: bool;
    l4var3z, l4var4z: word;
    l4exp5z, l4exp6z, l4var7z, l4var8z: eptr;
    routine: irptr;
    l4op10z: operator;
    l4typ11z: tptr;
    l4var12z: bool;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void stdCall;
const chkREAL = 0;  chkINT    = 1;  chkCHAR = 2;    chkSCALAR = 3;
      chkPTR  = 4;  chkFILE   = 5;  chkSET  = 6;    chkOTHER  = 7;
var
    l5op1z: operator;
    l5var2z: tptr;
    argKind: kind;
    asBitset: int;
    stProcNo, checkMode: int;
{
    curVal.i  =  routine@.low;
    stProcNo  =  curVal.i;
    if (SY != LPAREN) {
        requiredSymErr(LPAREN);
        goto 8888;
    };
    expression;
    if (((stProcNo >= fnEOF) &&
       (fnEOLN >= stProcNo)) &&
       not (curExpr@.op IN [GETELT..FILEPTR])) {
        error(27); /* errExpressionWhereVariableExpected */
        exit;
    };
    arg1Type  =  curExpr@.typ;
    if (arg1Type@.k == kindRange)
        arg1Type  =  arg1Type@.base;
    argKind  =  arg1Type@.k;
    if (arg1Type == realType)
        checkMode  =  chkREAL
    else if (arg1Type == intType)
        checkMode  =  chkINT
    else if (arg1Type == charType)
        checkMode  =  chkCHAR
    else if (argKind == kindScalar)
        checkMode  =  chkSCALAR
    else if (argKind == kindPtr)
        checkMode  =  chkPTR
    else if (argKind == kindFile)
        checkMode  =  chkFILE
    else {
        checkMode  =  chkOTHER;
    };
    asBitset  =  [stProcNo];
    if (not ((checkMode == chkREAL) &&
            (asBitset & [fnSQRT:fnTRUNC, fnREF, fnROUND] != 0U)
           || ((checkMode == chkINT) &&
         (asBitset&[fnSQRT:fnABS,fnODD,fnCHR,fnCARD,fnMINEL,fnREF,fnPTR] != 0U))
           || ((checkMode IN [chkCHAR, chkSCALAR, chkPTR]) &&
            (asBitset & [fnORD, fnSUCC, fnPRED, fnREF] != 0U))
           || ((checkMode == chkFILE) &&
            (asBitset & [fnEOF, fnREF, fnEOLN] != 0U))
           || ((checkMode == chkOTHER) &&
            (stProcNo == fnREF))))
        error(errNeedOtherTypesOfOperands);
    if (asBitset & [fnABS, fnSUCC, fnPRED] == 0U) {
        arg1Type  =  routine@.typ;
    } else if ((checkMode == chkINT) && (stProcNo == fnABS)) {
        stProcNo  =  fnABSI
    };
    new(l4exp6z);
    l4exp6z@.op  =  STANDPROC;
    l4exp6z@.expr1  =  curExpr;
    l4exp6z@.num2  =  stProcNo;
    if (stProcNo == fn24) {
        if (SY != COMMA) {
            requiredSymErr(COMMA);
            goto 8888;
        };
        expression;
        l5var2z  =  curExpr@.typ;
        l5op1z  =  badop27;
        if ((l5var2z != realType) &&
            not typeCheck(l5var2z, intType))
            error(errNeedOtherTypesOfOperands);
        if (l5var2z == realType)
            l5op1z  =  badop30
        else if (checkMode == chkREAL)
            l5op1z  =  badop31;
        l4exp6z@.expr2  =  curExpr;
        l4exp6z@.op  =  l5op1z;
    };
    curExpr  =  l4exp6z;
    curExpr@.typ  =  arg1Type;
    checkSymAndRead(RPAREN);
}; /* stdCall */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* factor */
    l4var2z  =  bool47z;
    bool47z  =  false;
    if (SY < MULOP) {
        switch (SY) {
        IDENT: {
            if (hashTravPtr == NIL) {
                error(errNotDefined);
                curExpr  =  uVarPtr;
            } else
                switch (hashTravPtr@.cl) {
                TYPEID: {
                    error(23); /* errTypeIdInsteadOfVar */
                    curExpr  =  uVarPtr;
                };
                ENUMID: {
                    new(curExpr);
                    with curExpr@ do {
                        typ  =  hashTravPtr@.typ;
                        op  =  GETENUM;
                        num1  =  hashTravPtr@.value;
                        num2  =  0;
                    };
                    inSymbol;
                };
                ROUTINEID: {
                    routine  =  hashTravPtr;
                    inSymbol;
                    if (routine@.offset == 0) {
                        if ((routine@.typ != NIL) &&
                           (SY == LPAREN)) {
                            stdCall;
                            exit;
                        };
                        error(44) /* errIncorrectUsageOfStandProcOrFunc */
                    } else if (routine@.typ == NIL) {
                        if (l4var2z) {
                            l4op10z  =  PCALL;
                        } else {
                            error(68); /* errUsingVoidInExpression */
                        }
                   } else {
                        if (SY == LPAREN) {
                            parseCallArgs(routine);
                            exit
                        };
                        if (l4var2z) {
                            l4op10z  =  FCALL;
                        } else {
                            parseCallArgs(routine);
                            exit
                        };
                    };
                    new(curExpr);
                    if (not (SY IN [RPAREN, COMMA])) {
                        error(errNoCommaOrParenOrTooFewArgs);
                        goto 8888;
                    };
                    with curExpr@ do {
                        typ  =  routine@.typ;
                        op  =  l4op10z;
                        expr1  =  NIL;
                        id2  =  routine;
                    }
                };
                VARID, FORMALID, FIELDID:
                    parseLval;
                } /* switch */
        };
        LPAREN: {
            expression;
            checkSymAndRead(RPAREN);
        };
        INTCONST, REALCONST, CHARCONST, LTSY: {
            new(curExpr);
            parseLiteral(curExpr@.typ, curExpr@.d1, false);
            curExpr@.num2  =  ord(numFormat);
            curExpr@.op  =  GETENUM;
            inSymbol;
        };
        NOTSY: {
            inSymbol;
            factor;
            if (curExpr@.typ != boolType)
                error(1); /* errNoCommaNorSemicolon */
            l4exp6z  =  curExpr;
            new(curExpr);
            with curExpr@ do {
                typ  =  boolType;
                op  =  NOTOP;
                expr1  =  l4exp6z;
            }
        };
        LBRACK: {
            new(curExpr);
            inSymbol;
            l4var8z  =  curExpr;
            l4var1z.m  =  [];
            if (SY != RBRACK) {
                l4var12z  =  true;
                readNext  =  false;
                do {
                    l4exp6z  =  curExpr;
                    expression;
                    if (l4var12z) {
                        l4typ11z  =  curExpr@.typ;
                        if (not (l4typ11z@.k IN [kindScalar, kindRange]))
                            error(23); /* errTypeIdInsteadOfVar */
                    } else {
                        if (not typeCheck(l4typ11z, curExpr@.typ))
                            error(24); /*errIncompatibleExprsInSetCtor*/
                    };
                    l4var12z  =  false;
                    l4exp5z  =  curExpr;
                    if (SY == COLON) {
                        expression;
                        if (not typeCheck(l4typ11z, curExpr@.typ))
                            error(24); /*errIncompatibleExprsInSetCtor*/
                        if ((l4exp5z@.op == GETENUM) &&
                           (curExpr@.op == GETENUM)) {
                            l4var4z.i  =  l4exp5z@.num1;
                            l4var3z.i  =  curExpr@.num1;
                            l4var4z.m  =  l4var4z.m ~ intZero;
                            l4var3z.m  =  l4var3z.m ~ intZero;
                            l4var1z.m  =  l4var1z.m | [l4var4z.i..l4var3z.i];
                            curExpr  =  l4exp6z;
                            goto 14567;
                        };
                        new(l4var7z);
                        with l4var7z@ do {
                            typ  =  intType;
                            op  =  MKRANGE;
                            expr1  =  l4exp5z;
                            expr2  =  curExpr;
                        };
                        l4exp5z  =  l4var7z;
                   } else {
                        if (l4exp5z@.op == GETENUM) {
                            l4var4z.i  =  l4exp5z@.num1;
                            l4var4z.m  =  l4var4z.m ~ intZero;
                            l4var1z.m  =  l4var1z.m | [l4var4z.i];
                            curExpr  =  l4exp6z;
                            goto 14567;
                        };
                        new(l4var7z);
                        with l4var7z@ do {
                            typ  =  intType;
                            op  =  STANDPROC;
                            expr1  =  l4exp5z;
                            num2  =  109;
                            l4exp5z  =  l4var7z;
                        }
                    };
                    new(curExpr);
                    with curExpr@ do {
                        typ  =  intType;
                        op  =  SETOR;
                        expr1  =  l4exp6z;
                        expr2  =  l4exp5z;
                    };
14567:              ;
                } while (SY == COMMA);
            };
            checkSymAndRead(RBRACK);
            with l4var8z@ do {
                op  =  GETENUM;
                typ  =  intType;
                d1  =  l4var1z;
            }
        };
        }; /* switch */
    } else {
        error(errBadSymbol);
        goto 8888;
    }
}; /* factor */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void term;
label
    14650;
var
    curOp: operator;
    leftArg, l4var3z: eptr;
    match: bool;
{
    factor;
    while (SY == MULOP) {
        curOp  =  charClass;
        inSymbol;
        leftArg  =  curExpr;
        factor;
        arg1Type  =  curExpr@.typ;
        arg2Type  =  leftArg@.typ;
        match  =  typeCheck(arg1Type, arg2Type);
        if ((not match) &&
           (RDIVOP < curOp))
14650:      error(errNeedOtherTypesOfOperands)
        else {
            switch (curOp) {
            MUL, RDIVOP: {
                if (match) {
                    if (arg1Type == realType) {
                        /* empty */
                    } else {
                        if (baseType == intType) {
                            arg1Type  =  intType;
                            curOp  =  imulOpMap[curOp];
                        } else {
                            goto 14650;
                        }
                    }
                } else {
                    if (areTypesCompatible(leftArg)) {
                        arg1Type  =  realType;
                    } else
                        goto 14650;
                }
            };
            SHLEFT, SHRIGHT: { arg1Type = arg2Type; };
            AMPERS: {
                if (arg1Type == intType)
                        curOp = SETAND
                    else if (arg1Type != boolType)
                        goto 14650;
            };
            IMODOP: {
                if (baseType == intType) {
                    arg1Type  =  intType;
                } else {
                    goto 14650;
                }
            };
            };
            new(l4var3z);
            with l4var3z@ do {
                op  =  curOp;
                expr1  =  leftArg;
                expr2  =  curExpr;
                curExpr  =  l4var3z;
                typ  =  arg1Type;
            }
        }
    }
}; /* term */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void simpleExpression;
label
    15031;
var
    l4var1z, l4var2z: eptr;
    l4var3z: operator;
    argKind: kind;
    match: bool;
{
    match  =  false;
    if (charClass IN [PLUSOP, MINUSOP]) {
        if (charClass == MINUSOP)
            match  =  true;
        inSymbol;
    };
    term;
(minus)
    if (match) {
        arg1Type  =  curExpr@.typ;
        new(l4var2z);
        with l4var2z@ do {
            typ  =  arg1Type;
            expr1  =  curExpr;
            if (arg1Type == realType) {
                op  =  RNEGOP;
            } else if (typeCheck(arg1Type, intType)) {
                l4var2z@.op  =  INEGOP;
                l4var2z@.typ  =  intType;
            } else {
                error(69); /* errUnaryMinusNeedRealOrInt */
                exit minus
            };
            curExpr  =  l4var2z;
        }
    };
    while (SY == ADDOP) {
        l4var3z  =  charClass;
        inSymbol;
        l4var2z  =  curExpr;
        term;
        arg1Type  =  curExpr@.typ;
        arg2Type  =  l4var2z@.typ;
        match  =  typeCheck(arg1Type, arg2Type);
        argKind  =  arg2Type@.k;
        if (kindArray <= argKind) {
15031:      error(errNeedOtherTypesOfOperands);
        } else {
            new(l4var1z);
            with l4var1z@ do {
                if (l4var3z == OROP) {
                    if ((not match) ||
                       (arg1Type != boolType))
                        goto 15031;
                    typ  =  boolType;
                    op  =  l4var3z;
                } else {
                    if ((l4var3z == SETOR) || (l4var3z == SETSUB)) {
                        op = l4var3z;
                        typ = arg1Type;
                    } else if (match) {
                    if (arg1Type == realType) {
                            op  =  l4var3z;
                            typ  =  realType;
                        } else if (baseType == intType) {
                            op  =  iAddOpMap[l4var3z];
                            typ  =  intType;
                        } else {
                            goto 15031
                        }
                    } else if (areTypesCompatible(l4var2z)) {
                        l4var1z@.typ  =  realType;
                        l4var1z@.op  =  l4var3z;
                    } else
                        goto 15031
                };
                l4var1z@.expr1  =  l4var2z;
                l4var1z@.expr2  =  curExpr;
                curExpr  =  l4var1z;
            }
        };
    }
}; /* simpleExpression */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parentExpression;
{
    if (readNext)
        inSymbol;
    checkSymAndRead(LPAREN);
    readNext  =  false;
    expression;
    checkSymAndRead(RPAREN);
};
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void expression;
var
    oper: operator;
    l4var2z, l4var3z: eptr;
{
    if (readNext)
        inSymbol
    else
        readNext  =  true;
    simpleExpression;
    if (SY == RELOP) {
        oper  =  charClass;
        inSymbol;
        l4var3z  =  curExpr;
        simpleExpression;
        arg1Type  =  curExpr@.typ;
        arg2Type  =  l4var3z@.typ;
        if (typeCheck(arg1Type, arg2Type)) {
            if (
               (arg1Type@.k == kindFile) ||
               (arg1Type@.size != 1) &&
               (oper >= LTOP) &&
               not isCharArray(arg1Type))
                error(errNeedOtherTypesOfOperands);
        } else {
            if (not areTypesCompatible(l4var3z) &&
               ((arg1Type != intType) ||
               not (arg2Type@.k IN [kindScalar, kindRange]) ||
               (oper != INOP))) {
                error(errNeedOtherTypesOfOperands);
            }
        };
        new(l4var2z);
        with l4var2z@ do {
            typ  =  boolType;
            if (oper IN [GTOP, LEOP]) {
                expr1  =  curExpr;
                expr2  =  l4var3z;
                if (oper == GTOP)
                    op  =  LTOP
                else
                    op  =  GEOP;
            } else {
                expr1  =  l4var3z;
                expr2  =  curExpr;
                op  =  oper;
            };
            curExpr  =  l4var2z;
        }
    }
}; /* expression */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void forStatement;
var
    l4typ1z: tptr;
    l4exp2z, l4var3z, l4var4z: eptr;
    l4int5z, l4int6z, l4int7z, l4int8z: int;
    l4var9z: bool;
{
    inSymbol;
    disableNorm;
    curExpr  =  NIL;
    if (SY == IDENT) {
        if ((hashTravPtr != NIL) && (hashTravPtr@.cl == VARID)) {
            parseLval;
            if (curExpr@.op != GETVAR)
                error(errNoSimpleVarForLoop);
        } else
            error(errNoSimpleVarForLoop);
    } else {
        errAndSkip(errNoIdent, skipToSet | [BECOMES, DOSY, TOSY, DOWNTOSY]);
    };
    if (curExpr == NIL)
        curExpr  =  uVarPtr;
    l4exp2z  =  curExpr;
    l4typ1z  =  l4exp2z@.typ;
    if (not (l4typ1z@.k IN [kindScalar, kindRange]))
        error(25); /* errExprNotOfADiscreteType */
    if (typeCheck(intType, l4typ1z))
        l4int5z  =  KATX+PLUS1
    else
        l4int5z  =  KATX+E1;
    if (SY == BECOMES) {
        expression;
        l4var9z  =  true;
    } else {
        l4var9z  =  false;
    };
    l4var3z  =  curExpr;
    l4int6z  =  insnTemp[ADD];
    if (not typeCheck(l4typ1z, l4var3z@.typ))
        error(31); /* errIncompatibleTypesOfLoopIndexAndExpr */
(todownto)
    if (SY == TOSY)
        exit todownto
    else if (SY == DOWNTOSY)
        l4int6z  =  insnTemp[SUB]
    else {
        error(70); /* errNeitherToNorDownto */
    };
    expression;
    if (not typeCheck(l4typ1z, curExpr@.typ))
        error(31); /* errIncompatibleTypesOfLoopIndexAndExpr */
    formOperator(gen0);
    l4var4z  =  curExpr;
    if (l4var9z) {
        curExpr  =  l4var3z;
        formOperator(LOAD);
    } else {
        form1Insn(insnTemp[XTA] + l4int5z);
    };
    l4int7z  =  0;
    disableNorm;
    formJump(l4int7z);
    padToLeft;
    l4int8z  =  moduleOffset;
    checkSymAndRead(DOSY);
    statement;
    disableNorm;
    curExpr  =  l4exp2z;
    formOperator(LOAD);
    form1Insn(l4int6z + l4int5z);
    P0715(0, l4int7z);
    formOperator(STORE);
    curExpr  =  l4var4z;
    if (l4int6z == insnTemp[SUB])
        curVal.i  =  l4int6z
    else
        curVal.i  =  insnTemp[RSUB];
    formOperator(gen3);
    form1Insn(insnTemp[UZA] + l4int8z);
}; /* forStatement */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void withStatement;
var
    l4exp1z: eptr;
    l4var2z, l4var3z: int;
    l4var4z: int;
{
    l4exp1z  =  expr63z;
    l4var4z  =  localSize;
    l4var2z  =  freeRegs;
    l4var3z  =  [];
    do {
        inSymbol;
        if ((hashTravPtr != NIL) &&
           (hashTravPtr@.cl >= VARID)) {
            parseLval;
            if (curExpr@.typ@.k == kindStruct) {
                formOperator(SETREG);
                l4var3z  =  (l4var3z | [curVal.i]) & set148z;
            } else {
                error(71); /* errWithOperatorNotOfARecord */
            };
        } else {
            error(72); /* errWithOperatorNotOfAVariable */
        }
    } while (SY == COMMA);
    checkSymAndRead(DOSY);
    statement;
    expr63z  =  l4exp1z;
    localSize  =  l4var4z;
    freeRegs  =  l4var2z;
    set145z  =  set145z | l4var3z;
}; /* withStatement */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void reportStmtType(l4arg1z: int);
{
    writeln(' STATEMENT ', stmtname:0, ' IN ', startLine:0, ' LINE');
}; /* reportStmtType */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function structBranch(isGoto: bool): bool;
var
    curLab: @strLabel;
{
    structBranch  =  true;
    if ((SY == IDENT) || not isGoto) {
        curLab  =  strLabList;
        ii  =  1;
        while (curLab != NIL) {
            with curLab@ do {
                if (ident.m == []) {
                    ii  =  ii - 1;
                } else {
                    if (ident == curIdent) {
                        if (ii == 1) {
                            if (isGoto) {
                                form1Insn(insnTemp[UJ] + offset);
                            } else {
                                formJump(curLab@.exitTarget);
                            };
                        } else {
                            form1Insn(getValueOrAllocSymtab(ii) +
                                      (KVTM+I13));
                            if (isGoto) {
                                form1Insn(KVTM+I10 + curLab@.offset);
                            } else {
                                jumpType  =  KVTM+I10;
                                formJump(curLab@.exitTarget);
                                jumpType  =  insnTemp[UJ];
                            };
                            form1Insn(getHelperProc(60) +
                                      06437777713700000U); /* P/ZAM */
                        };
                        exit
                    }
                };
                curLab  =  curLab@.next;
            }
        };
        if (not isGoto && (SY != IDENT)) {
            if (ii != 1) {
                form1Insn(getValueOrAllocSymtab(ii) + (KVTM+I13));
                form1Insn(getHelperProc(60)); /* P/ZAM */
            };
            formJump(exitTarget);
        } else {
            error(errNotDefined);
        }
    } else
        structBranch  =  false;
}; /* structBranch */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void caseStatement;
label
    16211;
type
    casechain = struct {
        next:   @casechain;
        value:  word;
        offset: int;
    };
var
    allClauses, curClause, clause, unused: @casechain;
    isIntCase: bool;
    otherSeen: bool;
    otherOffset: int;
    itemsEnded, goodMode: bool;
    firstType, itemtype, exprtype: tptr;
    itemvalue: word;
    itemSpan: int;
    expected: word;
    startLine, l4var17z, endOfStmt: int;
    minValue, unused2, maxValue: word;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function max(a, b: int): int;
{
    if (b < a)
        max  =  a
    else
        max  =  b;
}; /* max */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* caseStatement */
    startLine  =  lineCnt;
    parentExpression;
    exprtype  =  curExpr@.typ;
    otherSeen  =  false;
    if ((exprtype == alfaType) ||
       (exprtype@.k IN [kindScalar, kindRange]))
        formOperator(LOAD)
    else
        error(25); /* errExprNotOfADiscreteType */
    disableNorm;
    l4var17z  =  0;
    endOfStmt  =  0;
    allClauses  =  NIL;
    formJump(l4var17z);
    checkSymAndRead(BEGINSY);
    firstType  =  NIL;
    goodMode  =  true;
    do {
        if (not (SY IN [SEMICOLON, ENDSY])) {
            padToLeft;
            arithMode  =  1;
            if (SY == DEFAULTSY) {
                if (otherSeen)
                    error(73); /* errCaseLabelsIdentical */
                inSymbol;
                otherSeen  =  true;
                otherOffset  =  moduleOffset;
            } else do {
                parseLiteral(itemtype, itemvalue, true);
                if (itemtype != NIL) {
                    if (firstType == NIL) {
                        firstType  =  itemtype;
                    } else {
                        if (not typeCheck(itemtype, firstType))
                            error(errConstOfOtherTypeNeeded);
                    };
                    new(clause);
                    clause@.value  =  itemvalue;
                    clause@.offset  =  moduleOffset;
                    curClause  =  allClauses;
(loop)              while (curClause != NIL) {
                        if (itemvalue == curClause@.value) {
                            error(73); /* errCaseLabelsIdentical */
                            exit loop
                        } else if (itemvalue.i < curClause@.value.i) {
                            exit loop
                        } else {
                            unused  =  curClause;
                            curClause  =  curClause@.next;
                        }
                    };
                    if (curClause == allClauses) {
                        clause@.next  =  allClauses;
                        allClauses  =  clause;
                    } else {
                        clause@.next  =  curClause;
                        unused@.next  =  clause;
                    };
                    inSymbol;
                };
                itemsEnded  =  (SY != COMMA);
                if (not itemsEnded)
                    inSymbol;
            } while (not itemsEnded);
            checkSymAndRead(COLON);
            statement;
            goodMode  =  goodMode && (arithMode == 1);
            formJump(endOfStmt);
        };
        itemsEnded  =  (SY == ENDSY);
        if (not itemsEnded)
            inSymbol;
    } while (not itemsEnded);
    if (SY != ENDSY) {
        requiredSymErr(ENDSY);
        stmtName  =  'CASE  ';
        reportStmtType(startLine);
    } else
        inSymbol;
    if (not typeCheck(firstType, exprtype)) {
        error(88); /* errDifferentTypesOfLabelsAndExpr */;
        exit
    };
    padToLeft;
    isIntCase  =  typeCheck(exprtype, intType);
    if (allClauses != NIL) {
        expected  =  allClauses@.value;
        minValue  =  expected;
        curClause  =  allClauses;
        while (curClause != NIL) {
            if ((expected == curClause@.value) &&
               (exprtype@.k == kindScalar)) {
                maxValue  =  expected;
                if (isIntCase) {
                    expected.i  =  expected.i + 1;
                } else {
                    curVal  =  expected;
                    curVal.c  =  succ(curVal.c);
                    expected  =  curVal;
                };
                curClause  =  curClause@.next;
            } else {
                itemSpan  =  34000;
                P0715(0, l4var17z);
                if (firstType@.k == kindRange) {
                    itemSpan  =  max(abs(firstType@.left),
                                    abs(firstType@.right));
                } else {
                    if (firstType@.k == kindScalar)
                        itemSpan  =  firstType@.numen;
                };
                itemsEnded  =  (itemSpan < 32000);
                if (itemsEnded) {
                    form1Insn(KATI+14);
                } else {
                    form1Insn(KATX+SP+1);
                };
                minValue.i  =  (minValue.i - minValue.i); /* WTF? */
                while (allClauses != NIL) {
                    if (itemsEnded) {
                        curVal.i  =  (minValue.i - allClauses@.value.i);
                        curVal.m  =  (curVal.m | intZero);
                        form1Insn(getValueOrAllocSymtab(curVal.i) +
                                  (KUTM+I14));
                        form1Insn(KVZM+I14 + allClauses@.offset);
                        minValue  =  allClauses@.value;
                    } else {
                        form1Insn(KXTA+SP+1);
                        curVal  =  allClauses@.value;
                        form2Insn(KAEX + I8 + getFCSToffset,
                                  insnTemp[UZA] + allClauses@.offset);
                    };
                    allClauses  =  allClauses@.next;
                };
                if (otherSeen)
                    form1Insn(insnTemp[UJ] + otherOffset);
                goto 16211;
            }; /* if 16141 */
        }; /* while 16142 */
        if (not otherSeen) {
            otherOffset  =  moduleOffset;
            formJump(endOfStmt);
        };
        P0715(0, l4var17z);
        curVal  =  minValue;
        P0715(-(insnTemp[U1A]+otherOffset), maxValue.i);
        curVal  =  minValue;
        curVal.m  =  (curVal.m | intZero);
        form1Insn(KATI+14);
        curVal.i  =  ((moduleOffset + (1)) - curVal.i);
        if (curVal.i < 040000) {
            curVal.i  =  (curVal.i - 040000);
            curVal.i  =  allocSymtab(041000000U | (curVal.i & 077777U));
        };
        form1Insn(KUJ+I14 + curVal.i);
        while (allClauses != NIL) {
            padToLeft;
            form1Insn(insnTemp[UJ] + allClauses@.offset);
            allClauses  =  allClauses@.next;
        };
        16211:
        P0715(0, endOfStmt);
        if (not goodMode)
           disableNorm;
    }
}; /* caseStatement */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void assignStatement(doLHS: bool);
label
    16332;
var
    lhsExpr, assnExpr: eptr;
    indCnt: int;
    srcType, targType: tptr;
{
    if (doLHS)
        parseLval
    else {
        new(curExpr);
        with curExpr@ do {
            typ  =  hashTravPtr@.typ;
            op  =  GETVAR;
            id1  =  hashTravPtr;
        };
        inSymbol;
    };
    checkSymAndRead(BECOMES);
    readNext  =  false;
    targType  =  curExpr@.typ;
    if ((targType@.k == kindStruct) &&
       (SY == LBRACK)) {
        formOperator(SETREG9);
        indCnt  =  0;
        inSymbol;
        l3bool5z  =  false;
(indices)
        {
            if (SY == COMMA) {
                indCnt  =  indCnt + 1;
                inSymbol;
            } else if (SY == RBRACK) {
                inSymbol;
                exit indices;
            } else {
                readNext  =  false;
                expression;
                curVal.i  =  indCnt;
                formOperator(gen6);
            };
            goto indices;
        };
        curExpr  =  NIL;
    } else if ((SY == SEMICOLON) && allowCompat) {
        formOperator(STORE);
        readNext  =  true;
        curExpr  =  NIL;
    } else {
        lhsExpr  =  curExpr;
        expression;
        srcType  =  curExpr@.typ;
        if (typeCheck(targType, srcType)) {
            if (srcType@.k == kindFile)
                error(75) /*errCannotAssignFiles*/
            else {
                if (rangeMismatch && (targType@.k == kindRange)) {
                    new(assnExpr);
                    with assnExpr@ do {
                        typ  =  srcType;
                        op  =  BOUNDS;
                        expr1  =  curExpr;
                        typ2  =  targType;
                    };
                    curExpr  =  assnExpr;
                };
16332:          new(assnExpr);
                with assnExpr@ do {
                    typ  =  targType;
                    op  =  ASSIGNOP;
                    expr1  =  lhsExpr;
                    expr2  =  curExpr;
                };
                curExpr  =  assnExpr;
            }
        } else if ((targType == realType) &&
            typeCheck(intType, srcType)) {
            castToReal(curExpr);
            goto 16332;
        } else {
            error(33); /*errIllegalTypesForAssignment*/
        }
    }
}; /* assignStatement */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void compoundStatement;
{
(loop) {
        statement;
        if (SY == SEMICOLON) {
            inSymbol;
            goto loop;
        }
    }
}; /* compoundStatement */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void ifWhileStatement;
{
    disableNorm;
    parentExpression;
    if (curExpr@.typ != boolType)
        error(errBooleanNeeded)
    else {
        jumpTarget  =  0;
        formOperator(BRANCH);
        ifWhlTarget.i  =  jumpTarget;
    };
    statement;
}; /* ifWhileStatement */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseData;
label
    16545;
type
    DATAREC = struct {
        switch bool of
            false: {a: packed array [0..3] of 0..4095};
            true:  {b: int}
        };
var
    dsize, setcount: int;
    l4var3z, l4var4z, l4var5z: word;
    boundary: eptr;
    l4var7z, l4var8z, l4var9z: word;
    F: file of DATAREC;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P16432(l5arg1z: int);
var
    l5var1z: DATAREC;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function allocDataRef(l6arg1z: int): int;
{
    if (l6arg1z >= 2048) {
        curVal.i  =  l6arg1z;
        allocDataRef  =  allocSymtab((curVal.i | 040000000U) & halfWord);
    } else {
        allocDataRef  =  l6arg1z;
    }
}; /* allocDataRef */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* P16432 */
    l5var1z.a[0]  =  allocDataRef(l4var4z.i);
    if (FcstCnt == l4var3z.i) {
        curVal  =  l4var8z;
        curVal.i  =  addCurValToFCST;
    } else {
        curVal  =  l4var3z;
    };
    l5var1z.a[1]  =  allocSymtab(0400100000000U | curVal.i & halfWord);
    l5var1z.a[2]  =  allocDataRef(l5arg1z);
    if (l4var9z.i == 0) {
        curVal.i  =  l4var7z.i >> 24;
    } else {
        curVal.i  =  allocSymtab(l4var7z.i | l4var9z.i & halfWord);
    };
    l5var1z.a[3]  =  curVal.i;
    l4var9z.i  =  l5arg1z * l4var4z.i + l4var9z.i;
    F@  =  l5var1z;
    put(F);
    setcount  =  setcount + 1;
    l4var4z.i  =  0;
    l4var3z.i  =  FcstCnt;
}; /* P16432 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* parseData */
    dsize  =  FcstCnt;
    inSymbol;
    setcount  =  0;
(loop)
    do {
        inSymbol;
        setup(boundary);
        if (SY != IDENT) {
            if (SY == ENDSY)
                exit loop;
            error(errNoIdent);
            curExpr  =  uVarPtr;
        } else {
            if (hashTravPtr == NIL) {
16545:          error(errNotDefined);
                curExpr  =  uVarPtr;
                inSymbol;
            } else {
                if (hashTravPtr@.cl == VARID) {
                    parseLval;
                } else goto 16545;
            }
        };
        putLeft  =  true;
        objBufIdx  =  1;
        formOperator(SETREG9);
        if (objBufIdx != 1)
            error(errVarTooComplex);
        l4var7z.m  =  (leftInsn & [12,13,14,15,16,17,18,19,20,21,22,23]);
        l4var3z.i  =  FcstCnt;
        l4var4z.i  =  0;
        l4var9z.i  =  0;
        do {
            expression;
            formOperator(LITINSN);
            l4var8z  =  curVal;
            if (SY == COLON) {
                inSymbol;
                l4var5z  =  curToken;
                if (SY != INTCONST) {
                    error(62); /* errIntNeeded */
                    l4var5z.i  =  0;
                } else
                    inSymbol;
            } else
                l4var5z.i  =  1;
            if (l4var5z.i != 1) {
                if (l4var4z.i != 0)
                    P16432(1);
                l4var4z.i  =  1;
                P16432(l4var5z.i);
            } else {
                l4var4z.i  =  l4var4z.i + 1;
                if (SY == COMMA) {
                    curVal  =  l4var8z;
                    toFCST;
                } else {
                    if (l4var4z.i != 1) {
                        curVal  =  l4var8z;
                        toFCST;
                    };
                    P16432(1);
                }
            };
        } while (SY == COMMA);
        rollup(boundary);
    } while (SY == SEMICOLON);
    if (SY != ENDSY)
        error(errBadSymbol);
    reset(F);
    while (not eof(F)) {
        write(FCST, F@.b);
        get(F);
    };
    int92z  =  FcstCnt - dsize;
    FcstCnt  =  dsize;
    int93z  =  setcount;
}; /* parseData */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void standProc;
label
    17753, 20041;
var
    l4typ1z, l4typ2z, l4typ3z: tptr;
    l4var4z, l4var5z: eptr;
    l4exp6z: eptr;
    l4exp7z, l4exp8z, workExpr: eptr;
    l4bool10z,
    l4bool11z, l4bool12z: bool;
    l4var13z, l4var14z, l4var15z: word;
    procNo: int;
    helperNo: int;
    l4var18z: opgen;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void verifyType(t: tptr);
{
    if ((hashTravPtr != NIL) &&
       (hashTravPtr@.cl >= VARID)) {
        parseLval;
        if ((t != NIL) &&
           not typeCheck(t, curExpr@.typ))
            error(errNeedOtherTypesOfOperands);
    } else {
        error(errNotDefined);
        curExpr  =  uVarPtr;
    }
}; /* verifyType */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void startReadOrWrite(l5arg1z: bool);
{
    expression;
    l4typ3z  =  curExpr@.typ;
    l4exp7z  =  curExpr;
    if (not (l5arg1z)) {
        if (not (curExpr@.op IN lvalOpSet))
            error(27); /* errExpressionWhereVariableExpected */
    };
    if (workExpr == NIL) {
        if (l4typ3z@.k == kindFile) {
            workExpr  =  curExpr;
        } else {
            new(workExpr);
            workExpr@.typ  =  textType;
            workExpr@.op  =  GETVAR;
            if (l5arg1z) {
                workExpr@.id1  =  outputFile;
            } else {
                if (inputFile != NIL)
                    workExpr@.id1  =  inputFile
                else {
                    error(37); /* errInputMissingInProgramHeader */
                }
            }
        };
        arg2Type  =  workExpr@.typ;
        l4var13z.b  =  typeCheck(arg2Type@.base, charType);
        l4bool12z  =  true;
        new(l4exp8z);
        l4exp8z@.typ  =  arg2Type@.base;
        l4exp8z@.op  =  FILEPTR;
        l4exp8z@.expr1  =  workExpr;
        new(l4exp6z);
        l4exp6z@.typ  =  l4exp8z@.typ;
        l4exp6z@.op  =  ASSIGNOP;
        if (l5arg1z)
            l4exp6z@.expr1  =  l4exp8z
        else
            l4exp6z@.expr2  =  l4exp8z;
    }
}; /* startReadOrWrite */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseWidthSpecifier(var l5arg1z: eptr);
{
    expression;
    if (not typeCheck(intType, curExpr@.typ)) {
        error(14); /* errExprIsNotInt */
        curExpr  =  uVarPtr;
    };
    l5arg1z  =  curExpr;
}; /* parseWidthSpecifier */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void callHelperWithArg;
{
    if (([12] & set145z != 0U) || l4bool12z) {
        curExpr  =  workExpr;
        formOperator(gen8);
    };
    l4bool12z  =  false;
    formAndAlign(getHelperProc(helperNo));
    disableNorm;
}; /* callHelperWithArg */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void P17037;
{
    set145z  =  set145z ~ [12];
    if ((helperNo != 49) &&             /* P/RDC */
       not typeCheck(l4exp8z@.typ, l4exp7z@.typ))
        error(34) /* errTypeIsNotAFileElementType */
    else {
        if (helperNo == 29) {       /* P/PF */
            l4exp6z@.expr2  =  l4exp7z;
        } else {
            if (helperNo == 49)
                helperNo  =  30;         /* P/GF */
            l4exp6z@.expr1  =  l4exp7z;
        };
        curExpr  =  l4exp6z;
        formOperator(gen7);
        callHelperWithArg;
    }
}; /* P17037 */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void checkElementForReadWrite;
var
    l5typ1z: tptr;
{
    set145z  =  set145z ~ [12];
    if (l4typ3z@.k == kindRange)
        l4typ3z  =  l4typ3z@.base;
    curVarKind  =  l4typ3z@.k;
    helperNo  =  36;                   /* P/WI */
    if (l4typ3z == intType)
        l4var15z.i  =  10
    else if (l4typ3z == realType) {
        helperNo  =  37;               /* P/WR */
        l4var15z.i  =  14;
    } else if (l4typ3z == charType) {
        helperNo  =  38;               /* P/WC */
        l4var15z.i  =  1;
    } else if (curVarKind == kindScalar) {
        helperNo  =  41;               /* P/WX */
        dumpEnumNames(l4typ3z);
        l4var15z.i  =  8;
    } else if (isCharArray(l4typ3z)) {
        l5typ1z  =  ref(l4typ3z@.range@);
        l4var15z.i  =  l5typ1z@.right - l5typ1z@.left + 1;
        if (not (l4typ3z@.pck))
            helperNo  =  81            /* P/WA */
        else if (6 >= l4var15z.i)
            helperNo  =  39            /* P/A6 */
        else
            helperNo  =  40;           /* P/A7 */
    } else if (l4typ3z@.size == 1) {
        helperNo  =  42;               /* P/WO */
        l4var15z.i  =  17;
    } else {
        error(34); /* errTypeIsNotAFileElementType */
    }
}; /* checkElementForReadWrite */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void writeProc;
{
    workExpr  =  NIL;
    l4var13z.b  =  true;
    do {
        startReadOrWrite(true);
        if (l4exp7z != workExpr) {
            if (not (l4var13z.b)) {
                helperNo  =  29;         /* P/PF */
                P17037;
            } else {
                checkElementForReadWrite;
                l4var5z  =  NIL;
                l4var4z  =  NIL;
                if (SY == COLON)
                    parseWidthSpecifier(l4var4z);
                if (SY == COLON) {
                    parseWidthSpecifier(l4var5z);
                    if (helperNo != 37)     /* P/WR */
                        error(35); /* errSecondSpecifierForWriteOnlyForReal */
                } else {
                    if (curToken.i == litOct) {
                        helperNo  =  42; /* P/WO */
                        l4var15z.i  =  17;
                        if (l4typ3z@.size != 1)
                            error(34); /* errTypeIsNotAFileElementType */
                        inSymbol;
                    }
                };
                l4bool11z  =  false;
                if ((l4var4z == NIL) &&
                   (helperNo IN [38,39,40])) {  /* WC,A6,A7 */
                    helperNo  =  helperNo + 5;       /* CW,6A,7A */
                    l4bool11z  =  true;
                } else {
                    if (l4var4z == NIL) {
                        curVal  =  l4var15z;
                        formOperator(gen9);
                    } else {
                        curExpr  =  l4var4z;
                        formOperator(LOAD);
                    }
                };
                if (helperNo == 37) {       /* P/WR */
                    if (l4var5z == NIL) {
                        curVal.i  =  4;
                        form1Insn(KXTS+I8 + getFCSToffset);
                    } else {
                        curExpr  =  l4var5z;
                        formOperator(gen10);
                    }
                };
                curExpr  =  l4exp7z;
                if (l4bool11z) {
                    if (helperNo == 45)      /* P/7A */
                        l4var18z  =  gen11
                    else
                        l4var18z  =  LOAD;
                } else {
                    if ((helperNo == 40) ||       /* P/A7 */
                       (helperNo == 81))      /* P/WA */
                        l4var18z  =  gen12
                    else
                        l4var18z  =  gen10;
                };
                formOperator(l4var18z);
                if ((helperNo IN [39,40,44,45]) || /* A6,A7,6A,7A */
                   (helperNo == 81))
                    form1Insn(KVTM+I10 + l4var15z.i)
                else {
                    if (helperNo == 41)  /* P/WX */
                        form1Insn(KVTM+I11 + l4typ3z@.start);
                };
                callHelperWithArg;
            }
        }
    } while (SY == COMMA);
    if (procNo == 11) {
        helperNo  =  46;                 /* P/WL */
        callHelperWithArg;
    };
    set145z  =  set145z | [12];
    if (l4var14z.i == moduleOffset)
        error(36); /*errTooFewArguments */
}; /* writeProc */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void readProc;
label
    17346, 17362;
{
    workExpr  =  NIL;
    l4var13z.b  =  true;
    l4var14z.i  =  moduleOffset;
    do {
        startReadOrWrite(false);
        if (l4exp7z != workExpr) {
            if (not (l4var13z.b)) {
                helperNo  =  30;         /* P/GF */
17346:
                P17037;
           } else {
                checkElementForReadWrite;
                if (helperNo == 38) {       /* P/WC */
                    helperNo  =  49;             /* P/RDC */
                    goto 17346;
                };
                if ((helperNo == 39) ||           /* A6,A7 */
                   (helperNo == 40)) {
                    helperNo  =  51;             /* P/RA7 */
17362:
                    curExpr  =  l4exp7z;
                    formOperator(SETREG9);
                    form1Insn(KVTM+I10 + l4var15z.i);
                    callHelperWithArg;
                } else {
                    if (helperNo == 81) {   /* P/WA */
                        helperNo  =  90;         /* P/RA */
                        goto 17362;
                    };
                    helperNo  =  helperNo + 11;
                    callHelperWithArg;
                    curExpr  =  l4exp7z;
                    formOperator(STORE);
                }
            }
        }
    } while (SY == COMMA);
    set145z  =  set145z | [12];
    if (procNo == 13) {
        helperNo  =  53;                 /* P/RL */
        callHelperWithArg;
    };
    if (l4var14z.i == moduleOffset)
        error(36); /* errTooFewArguments */
}; /* readProc */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void checkArrayArg;
{
    verifyType(NIL);
    workExpr  =  curExpr;
    l4typ1z  =  curExpr@.typ;
    if ((l4typ1z@.pck) ||
       (l4typ1z@.k != kindArray))
        error(errNeedOtherTypesOfOperands);
    checkSymAndRead(COMMA);
    readNext  =  false;
    expression;
    l4exp8z  =  curExpr;
    if (not typeCheck(l4typ1z@.range, l4exp8z@.typ))
        error(errNeedOtherTypesOfOperands);
}; /* checkArrayArg */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void doPackUnpack;
var
    t: tptr;
{
    new(l4exp7z);
    l4exp7z@.typ  =  l4typ1z@.base;
    l4exp7z@.op  =  GETELT;
    l4exp7z@.expr1  =  workExpr;
    l4exp7z@.expr2  =  l4exp8z;
    t  =  ref(l4exp6z@.typ@);
    if ((t@.k != kindArray) ||
       not t@.pck ||
       not typeCheck(t@.base, l4typ1z@.base) ||
       not typeCheck(l4typ1z@.range, t@.range))
        error(errNeedOtherTypesOfOperands);
    new(curExpr);
    curExpr@.val.c  =  chr(procNo + 50);
    curExpr@.expr1  =  l4exp7z;
    curExpr@.expr2  =  l4exp6z;
    formOperator(gen16);
}; /* doPackUnpack */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* standProc */
    curVal.i  =  l3idr12z@.low;
    procNo  =  curVal.i;
    l4bool10z  =  (SY == LPAREN);
    l4var14z.i  =  moduleOffset;
    if (not l4bool10z &&
       (procNo IN [0:5,8:10,12,16:28]))
        error(45); /* errNoOpenParenForStandProc */
    if (procNo IN [0,1,2,3,4,5,8,9]) {
        inSymbol;
        if (hashTravPtr@.cl < VARID)
            error(46); /* errNoVarForStandProc */
        parseLval;
        arg1Type  =  curExpr@.typ;
        curVarKind  =  arg1Type@.k;
    };
    if (procNo < 7)
        jumpTarget  =  getHelperProc(29 + procNo); /* P/PF */
    switch (procNo) {
    0, 1, 2, 3: { /* put, get, rewrite, reset */
        if (curVarKind != kindFile)
            error(47); /* errNoVarOfFileType */
        if ((procNo == 3) && (SY == COMMA)) { // reset with file location
            formOperator(gen8);
            expression;
            if (not typeCheck(intType, curExpr@.typ))
                error(14); /* errExprIsNotInt */
            formOperator(LOAD);
            formAndAlign(getHelperProc(97)); /*"P/RE"*/
        } else {
            formOperator(FILEACCESS);
        }
    };
    4, 5: { /* new, free */
        if (curVarKind != kindPtr)
            error(13); /* errVarIsNotPointer */
        heapCallsCnt  =  heapCallsCnt + 1;
        workExpr  =  curExpr;
        if (procNo == 5)
            formOperator(SETREG9);
        l2typ13z  =  arg1Type@.base;
        ii  =  l2typ13z@.size;
        if (charClass == EQOP) {
            expression;
            if (not typeCheck(intType, curExpr@.typ))
                error(14); /* errExprIsNotInt */
            formOperator(LOAD);
            form1Insn(KATI+14);
        } else {
            if (arg1Type@.base@.k == kindStruct) {
                l4typ1z  =  l2typ13z@.base;
(loop)          while ((SY == COMMA) && (l4typ1z != NIL)) {
                    inSymbol;
                    parseLiteral(l4typ2z, curVal, true);
                    if (l4typ2z == NIL)
                        exit loop
                    else {
                        inSymbol;
(loop2)                 while (l4typ1z != NIL) {
                            l4typ2z  =  l4typ1z;
                            while (l4typ2z != NIL) {
                                if (l4typ2z@.sel == curVal) {
                                    ii  =  l4typ1z@.size;
                                    exit loop2;
                                };
                                l4typ2z  =  l4typ2z@.r6;
                            };
                            l4typ1z  =  l4typ1z@.next;
                        };
                    };
                }
            };
            form1Insn(KVTM+I14+getValueOrAllocSymtab(ii));
        };
        formAndAlign(jumpTarget);
        if (procNo == 4) {
            curExpr  =  workExpr;
            formOperator(STORE);
        }
    };
    6: { /* halt */
        formAndAlign(jumpTarget);
        exit
    };
    7: { /* stop */
        form1Insn(KE74);
        exit
    };
    8, 9: { /* setup, rollup */
        if (curVarKind != kindPtr)
            error(13); /* errVarIsNotPointer */
        if (procNo == 8) {
            form1Insn(KXTA+HEAPPTR);
            formOperator(STORE);
        } else {
            formOperator(LOAD);
            form1Insn(KATX+HEAPPTR);
        }
    };
    10: { /* write */
        writeProc;
    };
    11:
17753: { /* writeln */
        if (SY == LPAREN) {
            writeProc;
        } else {
            formAndAlign(getHelperProc(54)); /*"P/WOLN"*/
            exit
        }
    };
    12: { /* read */
        readProc;
    };
    13: { /* readln */
        if (SY == LPAREN) {
            readProc;
        } else {
            formAndAlign(getHelperProc(55)); /*"P/RILN"*/
            exit
        }
    };
    14: { /* exit */
        l4bool10z  =  (SY == LPAREN);
        if (l4bool10z)
            inSymbol;
        if (SY == IDENT) {
            if (not structBranch(false))
                error(1); /* errCommaOrSemicolonNeeded */
            inSymbol;
        } else {
            formJump(exitTarget);
        };
        if (not l4bool10z)
            exit
    };
    15: { /* debug */
        if (debugPrint IN optSflags.m) {
            procNo  =  11;
            goto 17753;
        };
        while (SY != RPAREN)
            inSymbol;
    };
    16: { /* besm */
        expression;
        formOperator(LITINSN);
        formAndAlign(curVal.i);
    };
    17: { /* mapia */
        l4typ1z  =  intType;
        l4typ2z  =  alfaType;
20041:
        expression;
        if (not typeCheck(curExpr@.typ, l4typ1z))
            error(errNeedOtherTypesOfOperands);
        checkSymAndRead(COMMA);
        formOperator(LOAD);
        if (procNo == 17) {
            form3Insn(ASN64-33, KAUX+BITS15, KAEX+ASCII0);
        } else {
            form3Insn(KAPX+BITS15, ASN64+33, KAEX+ZERO);
        };
        verifyType(l4typ2z);
        formOperator(STORE);
    };
    18: { /* mapai */
        l4typ1z  =  alfaType;
        l4typ2z  =  intType;
        goto 20041;
    };
    19, 20: { /* pck, unpck */
        inSymbol;
        verifyType(charType);
        checkSymAndRead(COMMA);
        formOperator(gen8);
        verifyType(alfaType);
        if (procNo == 20) {
            formOperator(LOAD);
        };
        formAndAlign(getHelperProc(procNo - 6));
        if (procNo == 19)
            formOperator(STORE);
    };
    21: { /* pack */
        inSymbol;
        checkArrayArg;
        checkSymAndRead(COMMA);
        verifyType(NIL);
        l4exp6z  =  curExpr;
        doPackUnpack;
    };
    22: { /* unpack */
        inSymbol;
        verifyType(NIL);
        l4exp6z  =  curExpr;
        checkSymAndRead(COMMA);
        checkArrayArg;
        doPackUnpack;
    };
    };
    if (procNo in [0,1,2,3,5,10,11,12,13,21,22])
        arithMode  =  1;
    checkSymAndRead(RPAREN);
}; /* standProc */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* statement */
    setup(boundary);
    bool110z  =  false;
    startLine  =  lineCnt;
    if (freeRegs == halfWord)
        parseData
    else {
        if (SY == INTCONST) {
            set146z  =  [];
            l3var2z  =  numLabList;
            disableNorm;
            l3bool5z  =  true;
            padToLeft;
            while (l3var2z != l2var16z) { with l3var2z@ do
                if (id != curToken) {
                    l3var2z  =  next;
                } else {
                    l3bool5z  =  false;
                    if (defined) {
                        curVal.i  =  line;
                        error(17); /* errLblAlreadyDefinedInLine */;
                    } else {
                        l3var2z@.line  =  lineCnt;
                        l3var2z@.defined  =  true;
                        padToLeft;
                        if (l3var2z@.offset == 0) {
                            /* empty */
                        } else if (l3var2z@.offset >= 074000) {
                            curVal.i  =  (moduleOffset - 040000);
                            symTab[l3var2z@.offset]  =  [24,29] |
                                                         curVal.m & 077777U;
                        } else {
                            P0715(0, l3var2z@.offset);
                        };
                        l3var2z@.offset  =  moduleOffset;
                    };
                    l3var2z  =  l2var16z;
                };
            }; /* while 20346 */
            if (l3bool5z)
                error(16); /* errLblNotDefinedInBlock */;
            inSymbol;
            checkSymAndRead(COLON);
        };
        l3var4z  =  (SY IN [BEGINSY,SWITCHSY]);
        if (l3var4z)
            lineNesting  =  lineNesting + 1;
(ident)
        if (SY == IDENT) {
            if (hashTravPtr != NIL) {
                l3var6z  =  hashTravPtr@.cl;
                if (l3var6z >= VARID) {
                    assignStatement(true);
                } else {
                    if (l3var6z == ROUTINEID) {
                        if (hashTravPtr@.typ == NIL) {
                            l3idr12z  =  hashTravPtr;
                            inSymbol;
                            if (l3idr12z@.offset == 0) {
                                standProc;
                                exit ident;
                            };
                            parseCallArgs(l3idr12z);
                        } else {
                            assignStatement(false);
                        };
                    } else {
                        error(32); /* errWrongStartOfOperator */
                        goto 8888;
                    }
                };
                formOperator(gen7);
            } else {
                error(errNotDefined);
8888:           skip(skipToSet | statEndSys);
            };
        } else if (SY == LPAREN) {
            set146z  =  [];
            inSymbol;
            if (SY != IDENT) {
                error(errNoIdent);
                goto 8888;
            };
            new(l3var3z);
            padToLeft;
            disableNorm;
            with l3var3z@ do {
                next  =  strLabList;
                ident  =  curIdent;
                offset  =  moduleOffset;
                exitTarget  =  0;
            };
            strLabList  =  l3var3z;
            inSymbol;
            checkSymAndRead(RPAREN);
            statement;
            P0715(0, l3var3z@.exitTarget);
            strLabList  =  strLabList@.next;
        } else if (SY == BEGINSY)
(rep)   {
            inSymbol;
(skip)      {
                compoundStatement;
                if (SY != ENDSY) {
                    stmtName  =  ' BEGIN';
                    requiredSymErr(SEMICOLON);
                    reportStmtType(startLine);
                    skip(bigSkipSet);
                    if (SY IN statBegSys)
                        goto skip;
                    if (SY != SEMICOLON)
                        exit rep;
                    goto rep;
                };
            };
            inSymbol;
        } else if (SY == GOTOSY) {
            inSymbol;
            if (SY != INTCONST) {
                if (structBranch(true)) {
                    inSymbol;
                    exit;
                } else
                    goto 8888;
            };
            disableNorm;
            l3var2z  =  numLabList;
(loop)      if (l3var2z != NIL)  with l3var2z@ do {
                if (id != curToken) {
                    l3var2z  =  next;
                } else {
                    if (curFrameRegTemplate == frame) {
                        if (offset >= 040000) {
                            form1Insn(insnTemp[UJ] + offset);
                        } else {
                            formJump(offset);
                        }
                    } else {
                        if (offset == 0) {
                            offset  =  symTabPos;
                            putToSymTab(0U);
                        };
                        form3Insn(frame + (KMTJ + 13), KVTM+I14 + offset,
                                  getHelperProc(18/*"P/RC"*/) + (-064100000));
                    };
                    exit loop;
                };
                goto loop;
            } else
                error(18); /* errLblNotDefined */
            inSymbol;
        } else if (SY == IFSY) {
            ifWhileStatement;
            if (SY == ELSESY) {
                elseJump.i  =  0;
                formJump(elseJump.i);
                P0715(0, ifWhlTarget.i);
                curOffset  =  arithMode;
                arithMode  =  1;
                inSymbol;
                statement;
                P0715(0, elseJump.i);
                if (curOffset != arithMode) {
                    arithMode  =  2;
                    disableNorm;
                }
            } else {
                P0715(0, ifWhlTarget.i);
            }
        } else if (SY == WHILESY) {
            set146z  =  [];
            disableNorm;
            padToLeft;
            curOffset  =  moduleOffset;
            ifWhileStatement;
            disableNorm;
            form1Insn(insnTemp[UJ] + curOffset);
            P0715(0, ifWhlTarget.i);
            arithMode  =  1;
        } else if (SY == DOSY) {
            set146z  =  [];
            disableNorm;
            padToLeft;
            curOffset  =  moduleOffset;
            inSymbol;
            statement;
            if (SY != WHILESY) {
                requiredSymErr(WHILESY);
                stmtName  =  '  DO  ';
                reportStmtType(startLine);
                goto 8888;
            };
            disableNorm;
            parentExpression;
            if (curExpr@.typ != boolType) {
                error(errBooleanNeeded)
            } else {
                jumpTarget  =  curOffset;
                whileExpr  =  curExpr;
                new (curExpr);
                with curExpr@ do {
                    typ  =  boolType;
                    op  =  NOTOP;
                    expr1  =  whileExpr;
                };
                formOperator(BRANCH);
            };
        } else if (SY == FORSY) {
            set146z  =  [];
            forStatement;
        } else if (SY == SWITCHSY) {
            caseStatement
        } else if (SY == WITHSY) {
            withStatement;
        };
        if (l3var4z)
            lineNesting  =  lineNesting - 1;
        rollup(boundary);
        if (bool110z) {
            bool110z  =  false;
            goto 8888;
        }
    }
}; /* statement */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void outputObjFile;
var
    idx: int;
{
    padToLeft;
    objBufIdx  =  objBufIdx - 1;
    for idx to objBufIdx do
        write(_CHILD_, objBuffer[idx]);
    lineStartOffset  =  moduleOffset;
    prevOpcode  =  0;
}; /* outputObjFile */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void defineRoutine;
var
    l3var1z, l3var2z, l3var3z: word;
    l3int4z: int;
    l3idr5z: irptr;
    l3var6z, l3var7z: word;
{
    objBufIdx  =  1;
    objBuffer[objBufIdx]  =  [];
    curInsnTemplate  =  insnTemp[XTA];
    bool48z  =  22 IN l2idr2z@.flags;
    lineStartOffset  =  moduleOffset;
    l3var1z  =  ;
    int92z  =  2;
    expr63z  =  NIL;
    arithMode  =  1;
    set146z  =  [];
    freeRegs  =  [curProcNesting+1..6];
    set148z  =  freeRegs ~ [minel(freeRegs)];
    l3var7z.m  =  freeRegs;
    exitTarget  =  0;
    set145z  =  [1:15] ~ freeRegs;
    if (curProcNesting != 1)
        parseDecls(2);
    l2int21z  =  localSize;
    if (SY != BEGINSY)
        requiredSymErr(BEGINSY);
    if (23 IN l2idr2z@.flags) {
        l3idr5z  =  l2idr2z@.argList;
        l3int4z  =  3;
        if (l2idr2z@.typ != NIL)
        l3int4z  =  4;
        while (l3idr5z != l2idr2z) {
            if (l3idr5z@.cl == VARID) {
                l3var2z.i  =  l3idr5z@.typ@.size;
                if (l3var2z.i != 1) {
                    form3Insn(KVTM+I14 + l3int4z,
                              KVTM+I12 + l3var2z.i,
                              KVTM+I11 + l3idr5z@.value);
                    formAndAlign(getHelperProc(73)); /* "P/LNGPAR" */
                }
            };
            l3int4z  =  l3int4z + 1;
            l3idr5z  =  l3idr5z@.list;
        }
    };
    if (checkBounds || not (NoStackCheck IN optSflags.m))
        P0715(-1, 95); /* P/SC */
    l3var2z.i  =  lineNesting;
    do {
        statement;
        if (SY == SEMICOLON) {
            if (curProcNesting == 1)
                requiredSymErr(PERIOD);
            inSymbol;
            l2bool8z  =  (SY IN blockBegSys);
            if (not l2bool8z && not errors)
                error(84); /* errErrorInDeclarations */
        } else {
            if ((SY == PERIOD) && (curProcNesting == 1))
                l2bool8z  =  true
            else {
                errAndSkip(errBadSymbol, skipToSet);
                l2bool8z  =  (SY IN blockBegSys);
            }
        };
    } while (not l2bool8z);
    l2idr2z@.flags  =  (set145z & [0:15]) | (l2idr2z@.flags ~ l3var7z.m);
    lineNesting  =  l3var2z.i - 1;
    if (exitTarget != 0)
        P0715(0, exitTarget);
    if (not bool48z && not doPMD && (l2int21z == 3) &&
       (curProcNesting != 1) && (set145z & [1:15] != [1:15])) {
        objBuffer[1]  =  [7:11,21:23,28,31];
        with l2idr2z@ do
            flags  =  flags | [25];
        if (objBufIdx == 2) {
            objBuffer[1]  =  [0,1,3:5];
            putLeft  =  true;
        } else {
            l2idr2z@.pos  =  l3var1z.i;
            if (13 IN set145z) {
                curVal.i  =  minel([1:15] ~ set145z);
                objBuffer[2]  =  objBuffer[2] | [0,1,3,6,9] | (curVal.m << 24);
            } else {
                curVal.i  =  13;
            };
            form1Insn(insnTemp[UJ] + indexreg[curVal.i]);
        }
    } else {
        if (l2int11z == 0)
            jj  =  27    /* P/E */
        else
            jj  =  28;   /* P/EF */
        form1Insn(getHelperProc(jj) + (-I13-0100000));
        if (curProcNesting == 1) {
            parseDecls(2);
            if (S3 IN optSflags.m)
                formAndAlign(getHelperProc(78)); /* "P/PMDSET" */
            form1Insn(insnTemp[UJ] + l3var1z.i);
            curVal.i  =  l2idr2z@.pos - 040000;
            symTab[074002]  =  [24,29] | (curVal.m & halfWord);
        };
        curVal.i  =  l2int21z;
        if (curProcNesting != 1) {
            l3var7z.i  =  (curVal.i - 2) << 24;
            objBuffer[savedObjIdx]  =
                objBuffer[savedObjIdx] | l3var7z.m | [0,1,2,3,4,6,8];
        }
    };
    outputObjFile;
}; /* defineRoutine */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void initScalars;
var
    l3var1z, l3var3z, l3var4z: word;
    l3var5z, l3var6z: int;
    l3var7z: irptr;
    l3var8z, l3var9z: int;
    temptype: tptr;
    l3var11z: word;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void regSysType(l4arg1z:int; l4arg2z: tptr);
{
    new(curIdRec = 5);
    curIdRec@  =  [l4arg1z, 0, , l4arg2z, TYPEID];
    addToHashTab(curIdRec);
}; /* regSysType */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void regSysEnum(l4arg1z: int; l4arg2z: int);
{
    new(curIdRec = 7);
    curIdRec@  =  [l4arg1z, 48, , temptype, ENUMID, NIL, l4arg2z];
    addToHashTab(curIdRec);
}; /* regSysEnum */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void regSysProc(l4arg1z: int);
{
    new(curIdRec = 6);
    curIdRec@  =  [l4arg1z, 0, , temptype, ROUTINEID, l3var9z];
    l3var9z  =  l3var9z + 1;
    addToHashTab(curIdRec);
}; /* registerSysProc */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* initScalars */
    new(boolType, kindScalar);
    with boolType@ do {
        size  =  1;
        bits  =  1;
        k  =  kindScalar;
        numen  =  2;
        start  =  0;
    };
    new(intType, kindScalar);
    with intType@ do {
        size  =  1;
        bits  =  48;
        k  =  kindScalar;
        numen  =  100000;
        start  =  -1;
        enums  =  NIL;
    };
    new(charType, kindScalar);
    with charType@ do {
        size  =  1;
        bits  =  8;
        k  =  kindScalar;
        numen  =  256;
        start  =  -1;
        enums  =  NIL;
    };
    new(realType, kindReal);
    with realType@ do {
        size  =  1;
        bits  =  48;
        k  =  kindReal;
    };
    new(pointerType, kindPtr);
    with pointerType@ do {
        size  =  1;
        bits  =  48;
        k  =  kindPtr;
        base  =  pointerType;
    };
    new(textType, kindFile);
    with textType@ do {
        size  =  30;
        bits  =  48;
        k  =  kindFile;
        base  =  charType;
        elsize  =  8;
    };
    new(alfaType,kindArray);
    with alfaType@ do {
        size  =  1;
        bits  =  48;
        k  =  kindArray;
        base  =  charType;
        range  =  temptype;
        pck  =  true;
        perword  =  6;
        pcksize  =  8;
    };
    smallStringType[6]  =  alfaType;
     /*=A3 constructing TEXT constants */
    regSysType('     INT', intType);
    regSysType('    BOOL', boolType);
    regSysType('    CHAR', charType);
    regSysType('    REAL', realType);
    regSysType('    ALFA', alfaType);
    regSysType('    TEXT', textType);
    temptype  =  boolType;
    regSysEnum('    TRUE', 1U);
    hashTravPtr  =  curIdRec;
    regSysEnum('   FALSE', 0U);
    curIdRec@.list  =  hashTravPtr;
    boolType@.enums  =  curIdRec;
    tempType = pointerType;
    regSysEnum('     NIL', 074000U);
    maxSmallString  =  0;
    for strLen  =  2 to 5 do
        makeStringType(smallStringType[strLen]);
    maxSmallString  =  6;
    new(curIdRec = 7);
    with curIdRec@ do {
        offset  =  0;
        typ  =  intType;
        cl  =  VARID;
        list  =  NIL;
        value  =  7;
    };
    new(uVarPtr);
    with uVarPtr@ do {
        typ  =  intType;
        op  =  GETVAR;
        id1  =  curIdRec;
    };
    new(uProcPtr, 12);
    with uProcPtr@ do {
        typ  =  NIL;
        list  =  NIL;
        argList  =  NIL;
        preDefLink  =  NIL;
        pos  =  0;
    };
    temptype  =  NIL;
    l3var9z  =  0;
    for l3var5z  =  0 to 22 do
        regSysProc(systemProcNames[l3var5z]);
    l3var9z  =  0;
    temptype  =  realType;
    regSysProc('    SQRT');
    regSysProc('     SIN');
    regSysProc('     COS');
    regSysProc('  ARCTAN');
    regSysProc('  ARCSIN');
    regSysProc('      LN');
    regSysProc('     EXP');
    regSysProc('     ABS');
    temptype  =  intType;
    regSysProc('   TRUNC');
    temptype  =  boolType;
    regSysProc('     ODD');
    temptype  =  intType;
    regSysProc('     ORD');
    temptype  =  charType;
    regSysProc('     CHR');
    regSysProc('    SUCC');
    regSysProc('    PRED');
    temptype  =  boolType;
    regSysProc('     EOF');
    temptype  =  pointerType;
    regSysProc('     REF');
    temptype  =  boolType;
    regSysProc('    EOLN');
    temptype  =  intType;
    regSysProc('        '); /* was SQR, fn17 */
    regSysProc('   ROUND');
    regSysProc('    CARD');
    regSysProc('   MINEL');
    temptype  =  pointerType;
    regSysProc('     PTR');
    l3var11z.i  =  30;
    l3var11z.m  =  l3var11z.m & halfWord | [24,27,28,29];
    new(programObj, 12);
    l3var3z.i  = '*OUTPUT*';
    l3var4z.i  =  ' *INPUT*';
    test1(EXTERNSY, (skipToSet | [IDENT,LPAREN]));
    symTabPos  =  074004;
    with programObj@ do {
        curVal.i  =  'PASCOMPL';
        id  =  ;
        pos  =  0;
        symTab[074000]  =  makeNameWithStars(true);
    };
    entryPtTable[1].m  =  symTab[074000];
    entryPtTable[3].i  = 'PROGRAM ';
    entryPtTable[2]  =  [1];
    entryPtTable[4]  =  [1];
    entryPtCnt  =  5;
    /*10 24 74001 00 30 74002*/
    write(_CHILD_,04247400103074002U);
    moduleOffset  =  040001;
    programObj@.argList  =  NIL;
    programObj@.flags  =  [];
    objBufIdx  =  1;
    temptype  =  intType;
    defineRange(temptype, 1, 6);
    alfaType@.range  =  temptype;
    int93z  =  0;
    outputObjFile;
    outputFile  =  NIL;
    inputFile  =  NIL;
    externFileList  =  NIL;
    new(l3var7z, 12);
    lineStartOffset  =  moduleOffset;
    with l3var7z@ do {
        id  =  l3var3z;
        offset  =  0;
        typ  =  textType;
        cl  =  VARID;
        list  =  NIL;
    };
    curVal.i  =  '*OUTPUT*';
    /*=A2 done with TEXT constants */
    l3var7z@.value  =  allocExtSymbol(l3var11z.i);
    addToHashTab(l3var7z);
    l3var5z  =  1;
    while (SY == IDENT) {
        l3var8z  =  0;
        curVal  =  curIdent;
        l3var1z.m  =  makeNameWithStars(false);
        if (curIdent == l3var4z) {
            new(inputFile, 12);
            with inputFile@ do {
                id  =  curIdent;
                offset  =  0;
                typ  =  textType;
                cl  =  VARID;
                list  =  NIL;
            };
            curVal  =  l3var1z;
            inputFile@.value  =  allocExtSymbol(l3var11z.i);
            addToHashTab(inputFile);
            l3var8z  =  lineCnt;
        } else if (curIdent == l3var3z) {
            outputFile  =  l3var7z;
            l3var8z  =  lineCnt;
        };
        curExternFile  =  externFileList;
        while (curExternFile != NIL) {
            if (curExternFile@.id == curIdent) {
                curExternFile  =  NIL;
                error(errIdentAlreadyDefined);
            } else {
                curExternFile  =  curExternFile@.next;
            };
        };
        new(curExternFile);
        with curExternFile@ do {
            id  =  curIdent;
            next  =  externFileList;
            line  =  l3var8z;
            offset  =  l3var1z.i;
        };
        if (l3var8z != 0) {
            if (curIdent == l3var3z) {
                fileForOutput  =  curExternFile;
            } else {
                fileForInput  =  curExternFile;
            }
        };
        externFileList  =  curExternFile;
        l3var6z  =  l3var5z;
        l3var5z  =  l3var5z + 1;
        inSymbol;
        if (charClass == MUL) {
            l3var6z  =  l3var6z + 64;
            inSymbol;
        };
        if (SY == INTCONST) {
            l3var6z  =  01000 * curToken.i + l3var6z;
            if ((numFormat == DECIMAL) &&
               (1 < curToken.i) &&
               (curToken.i < 127)) {
                l3var6z  =  l3var6z + 128;
            } else if ((numFormat == OCTAL) &&
                      (01000000 < curToken.i) &&
                      (curToken.i < 01743671743)) {
                l3var6z  =  l3var6z + 256;
            } else {
                error(76); /* errWrongNumberForExternalFile */
            };
            inSymbol;
        } else {
            l3var6z  =  512;
        };
        curExternFile@.location  =  l3var6z;
        if (SY == COMMA)
            inSymbol;
    };
    checkSymAndRead(SEMICOLON);
    if (outputFile == NIL) {
        error(77); /* errNoOutput */
        outputFile  =  l3var7z;
    };
    l3var6z  =  40;
    do {
        programme(l3var6z, programObj);
    } while (SY != PERIOD);
    if (CH != 'D') {
        int92z  =  0;
        int93z  =  ;
    } else {
        freeRegs  =  halfWord;
        dataCheck  =  false;
        statement;
    };
    readToPos80;
    curVal.i  =  l3var6z;
    symTab[074003]  =  (helperNames[25] | [24,27,28,29]) |
                        (curVal.m & halfWord);
}; /* initScalars */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void makeExtFile;
{
    new(l2var10z);
    with l2var10z@ do {
        typ  =  ptr(ord(curExternFile));
        id2  =  workidr;
        expr1  =  curExpr;
    };
    curExpr  =  l2var10z;
}; /* makeExtFile */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void parseParameters;
var
    l3var1z, l3var2z, l3var3z: irptr;
    parClass: idclass;
    l3var5z, l3var6z: int;
    l3sym7z: symbol;
    noComma: bool;
    expType: tptr;
{
    int92z  =  0;
    l3var5z  =  0;
    int93z  =  0;
    inSymbol;
    l3var2z  =  NIL;
    if (not (SY IN [IDENT,VARSY,FUNCSY,VOIDSY]))
        errAndSkip(errBadSymbol, (skipToSet | [IDENT,RPAREN]));
    int92z  =  1;
    while (SY IN [IDENT,VARSY,FUNCSY,VOIDSY]) {
        l3sym7z  =  SY;
        if (SY == IDENT)
            parClass  =  VARID
        else if (SY == VARSY)
            parClass  =  FORMALID
        else {
            parClass  =  ROUTINEID;
        };
        l3var3z  =  NIL;
        if (SY == VOIDSY)
            expType  =  NIL
        else
            expType  =  intType;
        l3var6z  =  0;
        if (SY != IDENT) {
            int93z  =  0;
            inSymbol;
        };
        do {
          if (SY == IDENT) {
            if (isDefined)
                error(errIdentAlreadyDefined);
            l3var6z  =  l3var6z + 1;
            new(l3var1z, FORMALID);
            with l3var1z@ do {
                id  =  curIdent;
                offset  =  curFrameRegTemplate;
                cl  =  parClass;
                next  =  symHashTabBase[bucket];
                typ  =  NIL;
                list  =  curIdRec;
                value  =  l2int18z;
            };
            symHashTabBase[bucket]  =  l3var1z;
            l2int18z  =  l2int18z + 1;
            if (l3var2z == NIL)
                curIdRec@.argList  =  l3var1z
            else
                l3var2z@.list  =  l3var1z;
            l3var2z  =  l3var1z;
            if (l3var3z == NIL)
                l3var3z  =  l3var1z;
            inSymbol;
        } else
            errAndSkip(errNoIdent, skipToSet | [RPAREN,COMMA,COLON]);
        noComma  =  (SY != COMMA);
        if (not noComma) {
            int93z  =  0;
            inSymbol;
        };
        } while (not noComma);
        if (l3sym7z != VOIDSY) {
            checkSymAndRead(COLON);
            parseTypeRef(expType, (skipToSet | [IDENT,RPAREN]));
            if (l3sym7z != VARSY) {
                if (isFileType(expType))
                error(5) /*errSimpleTypeReq */
                else if (expType@.size != 1)
                     l3var5z  =  l3var6z * expType@.size + l3var5z;
            };
            if (l3var3z != NIL)
                while (l3var3z != curIdRec) with l3var3z@ do {
                    typ  =  expType;
                    l3var3z  =  list;
                };
        };
        if (SY == SEMICOLON) {
            int93z  =  0;
            inSymbol;
            if (not (SY IN (skipToSet | [IDENT,VARSY,FUNCSY,VOIDSY])))
                errAndSkip(errBadSymbol, (skipToSet | [IDENT,RPAREN]));
        };
    };
    if (l3var5z != 0) {
        curIdRec@.flags  =  (curIdRec@.flags | [23]);
        l3var6z  =  l2int18z;
        l2int18z  =  l2int18z + l3var5z;
        l3var2z  =  curIdRec@.argList;
        while (l3var2z != curIdRec) {
            if (l3var2z@.cl == VARID) {
                l3var5z  =  l3var2z@.typ@.size;
                if (l3var5z != 1) {
                    l3var2z@.value  =  l3var6z;
                    l3var6z  =  l3var6z + l3var5z;
                }
            };
            l3var2z  =  l3var2z@.list;
        };
    };
    checkSymAndRead (RPAREN);
}; /* parseParameters */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void exitScope(var arg: array [0..127] of irptr);
{
    for ii  =  0 to 127 do {
        workidr  =  arg[ii];
        while ((workidr != NIL) &&
              (workidr >= scopeBound))
            workidr  =  workidr@.next;
        arg[ii]  =  workidr;
    };
}; /* exitScope */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//
{ /* programme */
    localSize  =  l2arg1z;
    if (localSize == 0) {
        inSymbol;
        initScalars;
        exit;
    };
    preDefHead  =  ptr(0);
    inTypeDef  =  false;
    l2int11z  =  0;
    strLabList  =  NIL;
    lineNesting  =  lineNesting + 1;
    l2var16z  =  numLabList;
    do {
    if (SY == LABELSY) {
        do {
            inSymbol;
            if (SY != INTCONST) {
                requiredSymErr(INTCONST);
                goto 22421;
            };
            l2var15z  =  numLabList;
            while (l2var15z != l2var16z) {
                if (l2var15z@.id != curToken) {
                    l2var15z  =  l2var15z@.next;
                } else {
                    int97z  =  l2var15z@.line;
                    error(17); /* errLblAlreadyDefinedInLine */
                    goto 22420;
                }
            };
            new(l2var15z);
            with l2var15z@ do {
                id  =  curToken;
                frame  =  curFrameRegTemplate;
                offset  =  0;
                line  =  lineCnt;
                defined  =  false;
                next  =  numLabList;
            };
            numLabList  =  l2var15z;
22420:      inSymbol;
22421:      if (not (SY IN [COMMA,SEMICOLON]))
                errAndSkip(1, skipToSet | [COMMA,SEMICOLON]);
        } while (SY == COMMA);
        if (SY == SEMICOLON)
            inSymbol;
    };
    if (SY == CONSTSY) {
        parseDecls(0);
        while  (SY == IDENT) {
            if (isDefined)
                error(errIdentAlreadyDefined);
            new(workidr=7);
            workidr@  =  [curIdent, curFrameRegTemplate,
                           symHashTabBase[bucket], , ENUMID, NIL];
            symHashTabBase[bucket]  =  workidr;
            inSymbol;
            if (charClass != EQOP)
                error(errBadSymbol)
            else
                inSymbol;
            with workidr@ do
                parseLiteral(typ, high, true);
            if (workidr@.typ == NIL) {
                error(errNoConstant);
                workidr@.typ  =  intType;
                workidr@.value  =  1;
            } else
                inSymbol;
            if (SY == SEMICOLON) {
                int93z  =  0;
                inSymbol;
                if (not (SY IN (skipToSet | [IDENT]))) {
                    errAndSkip(errBadSymbol, skipToSet | [IDENT]);
                }
            } else {
                requiredSymErr(SEMICOLON);
            }
        }
    };
    objBufIdx  =  1;
    if (SY == TYPESY) {
        inTypeDef  =  true;
        typelist  =  NIL;
        parseDecls(0);
        while (SY == IDENT) {
            if (isDefined)
                error(errIdentAlreadyDefined);
            ii  =  bucket;
            l2var12z  =  curIdent;
            inSymbol;
            if (charClass != EQOP)
                error(errBadSymbol)
            else
                inSymbol;
            parseTypeRef(l2typ13z, skipToSet | [SEMICOLON]);
            curIdent  =  l2var12z;
            if (knownInType(curIdRec)) {
                l2typ14z  =  curIdRec@.typ;
                if (l2typ14z@.base == boolType) {
                    if (l2typ13z@.k != kindPtr) {
                        parseDecls(1);
                        error(78); /* errPredefinedAsPointer */
                    };
                    l2typ14z@.base  =  l2typ13z@.base;
                } else {
                    l2typ14z@.base  =  l2typ13z;
                    curIdRec@.typ  =  l2typ13z;
                };
                P2672(typelist, curIdRec);
            } else {
                new(curIdRec=5);
                with curIdRec@ do {
                    id  =  l2var12z;
                    offset  =  curFrameRegTemplate;
                    typ  =  l2typ13z;
                    cl  =  TYPEID;
                }
            };
            curIdRec@.next  =  symHashTabBase[ii];
            symHashTabBase[ii]  =  curIdRec;
            int93z  =  0;
            checkSymAndRead(SEMICOLON);
        };
        while (typelist != NIL) {
            l2var12z  =  typelist@.id;
            curIdRec  =  typelist;
            parseDecls(1);
            error(79); /* errNotFullyDefined */
            typelist  =  typelist@.next;
        }
    };
    inTypeDef  =  false;
    curExpr  =  NIL;
    if (SY == VARSY) {
        parseDecls(0);
        do {
            workidr  =  NIL;
            do {
            if (SY == IDENT) {
                new(curIdRec=7);
                if (isDefined)
                    error(errIdentAlreadyDefined);
                with curIdRec@ do {
                    id  =  curIdent;
                    offset  =  curFrameRegTemplate;
                    next  =  symHashTabBase[bucket];
                    cl  =  VARID;
                    list  =  NIL;
                };
                symHashTabBase[bucket]  =  curIdRec;
                inSymbol;
                if (workidr == NIL)
                    workidr  =  curIdRec
                else
                    l2var4z@.list  =  curIdRec;
                l2var4z  =  curIdRec;
            } else
                error(errNoIdent);
            if (not (SY IN [COMMA,COLON]))
                errAndSkip(1, skipToSet | [IDENT,COMMA]);
            l2bool8z  =  SY != COMMA;
            if (not l2bool8z) {
                int93z  =  0;
                inSymbol;
            };
            } while (not l2bool8z);
            checkSymAndRead(COLON);
            parseTypeRef(l2typ13z, skipToSet | [IDENT,SEMICOLON]);
            jj  =  l2typ13z@.size;
            while (workidr != NIL) with workidr@ do {
                curIdRec  =  list;
                typ  =  l2typ13z;
                list  =  NIL;
                l2bool8z  =  true;
                if (curProcNesting == 1) {
                    curExternFile  =  externFileList;
                    l2var12z  =  id;
                    curVal.i  =  jj;
                    toAlloc  =  curVal.m & halfWord | [24,27,28,29];
                    while (l2bool8z && (curExternFile != NIL)) {
                        if (curExternFile@.id == l2var12z) {
                            l2bool8z  =  false;
                            if (curExternFile@.line == 0) {
                                curVal.i  =  curExternFile@.offset;
                                workidr@.value  =  allocExtSymbol(toAlloc);
                                curExternFile@.line  =  lineCnt;
                            }
                        } else {
                            curExternFile  =  curExternFile@.next;
                        }
                    }
                };
                if (l2bool8z) {
                    workidr@.value  =  localSize;
                    if (PASINFOR.listMode == 3) {
                        write('VARIABLE ':25);
                        printTextWord(workidr@.id);
                        writeln(' OFFSET (', curProcNesting:0, ') ',
                                localSize:5 oct, 'B. WORDS=',
                                jj:5 oct, 'B');
                    };
                    localSize  =  localSize + jj;
                    curExternFile  =  NIL;
                };
                if (isFileType(l2typ13z))
                    makeExtFile;
                workidr  =  curIdRec;
            };
            int93z  =  0;
            checkSymAndRead(SEMICOLON);
            if ((SY != IDENT) && not (SY IN skipToSet))
                errAndSkip(errBadSymbol, skipToSet | [IDENT]);
        } while (SY == IDENT);
    };
    if (curProcNesting == 1) {
        workidr  =  outputFile;
        curExternFile  =  fileForOutput;
        makeExtFile;
        if (inputFile != NIL) {
            workidr  =  inputFile;
            curExternFile  =  fileForInput;
            makeExtFile;
        }
    };
    if (curExpr != NIL) {
        l2int11z  =  moduleOffset;
        formOperator(gen14);
    } else
        l2int11z  =  0;
    if (curProcNesting == 1) {
        curExternFile  =  externFileList;
        while (curExternFile != NIL) {
            if (curExternFile@.line == 0) {
                error(80); /* errUndefinedExternFile */
                printTextWord(curExternFile@.id);
                writeLN;
            };
            curExternFile  =  curExternFile@.next;
        }
    };
    outputObjFile;
    while ((SY == VOIDSY) || (SY == FUNCSY)) {
        l2bool8z  =  SY == VOIDSY;
        if (curFrameRegTemplate == 7) {
            error(81); /* errProcNestingTooDeep */
        };
        int93z  =  0;
        inSymbol;
        if (SY != IDENT) {
            error(errNoIdent);
            curIdRec  =  uProcPtr;
            isPredefined  =  false;
        } else {
            if (isDefined)  with hashTravPtr@ do {
                if ((cl == ROUTINEID) &&
                   (list == NIL) &&
                   (preDefLink != NIL) &&
                   ((typ == NIL) == l2bool8z)) {
                    isPredefined  =  true;
                } else {
                    isPredefined  =  false;
                    error(errIdentAlreadyDefined);
                    printErrMsg(82); /* errPrevDeclWasNotForward */
                };
            } else
                isPredefined  =  false;
        };
        if (not isPredefined) {
            new(curIdRec, 12);
            with curIdRec@ do {
                id  =  curIdent;
                offset  =  curFrameRegTemplate;
                next  =  symHashTabBase[bucket];
                typ  =  NIL;
                symHashTabBase[bucket]  =  curIdRec;
                cl  =  ROUTINEID;
                list  =  NIL;
                value  =  0;
                argList  =  NIL;
                preDefLink  =  NIL;
                if (declExternal)
                    flags  =  [0:15,22]
                else
                    flags  =  [0:15];
                pos  =  0;
                curFrameRegTemplate  =  curFrameRegTemplate + frameRegTemplate;
                if (l2bool8z)
                    l2int18z  =  3
                else
                    l2int18z  =  4;
            };
            curProcNesting  =  curProcNesting + 1;
            inSymbol;
            if (6 < curProcNesting)
                error(81); /* errProcNestingTooDeep */
            if (not (SY IN [LPAREN,SEMICOLON,COLON]))
                errAndSkip(errBadSymbol, skipToSet | [LPAREN,SEMICOLON,COLON]);
            if (SY == LPAREN)
                parseParameters;
            if (not l2bool8z) {
                if (SY != COLON)
                    errAndSkip(106 /*:*/, skipToSet | [SEMICOLON])
                else {
                    inSymbol;
                    parseTypeRef(curIdRec@.typ, skipToSet | [SEMICOLON]);
                    if (curIdRec@.typ@.size != 1)
                        error(errTypeMustNotBeFile);
                }
            };
        } else {
            with hashTravPtr@ do {
                l2int18z  =  level;
                curFrameRegTemplate  =  curFrameRegTemplate + indexreg[1];
                curProcNesting  =  curProcNesting + 1;
                if (preDefHead == hashTravPtr) {
                    preDefHead  =  preDefLink;
                } else {
                    curIdRec  =  preDefHead;
                    while (hashTravPtr != curIdRec) {
                        workidr  =  curIdRec;
                        curIdRec  =  curIdRec@.preDefLink;
                    };
                    workidr@.preDefLink  =  hashTravPtr@.preDefLink;
                }
            };
            hashTravPtr@.preDefLink  =  NIL;
            curIdRec  =  hashTravPtr@.argList;
            if (curIdRec != NIL) {
                while (curIdRec != hashTravPtr) {
                    addToHashTab(curIdRec);
                    curIdRec  =  curIdRec@.list;
                }
            };
            curIdRec  =  hashTravPtr;
            setup(scopeBound);
            inSymbol;
        };
        checkSymAndRead(SEMICOLON);
        with curIdRec@ do if (curIdent.i == litForward) {
            if (isPredefined)
                error(83); /* errRepeatedPredefinition */
            level  =  l2int18z;
            preDefLink  =  preDefHead;
            preDefHead  =  curIdRec;
        } else if ((SY == EXTERNSY) ||
            (curIdent.i == litFortran)) {
            if (SY == EXTERNSY) {
                curVal.m  =  [20];
            } else if (checkFortran) {
                curVal.m  =  [21,24];
                checkFortran  =  false;
            } else {
                curVal.m  =  [21];
            };
            curIdRec@.flags  =  curIdRec@.flags | curVal.m;
        } else {
            do {
                setup(scopeBound);
                programme(l2int18z, curIdRec);
                if (not (SY IN [FUNCSY,VOIDSY,BEGINSY]))
                    errAndSkip(errBadSymbol, skipToSet);
            } while (not (SY IN [FUNCSY,VOIDSY,BEGINSY]));
            rollup(scopeBound);
            exitScope(symHashTabBase);
            exitScope(typeHashTabBase);
            goto 23301;
        };
        inSymbol;
        checkSymAndRead(SEMICOLON);
23301:  workidr  =  curIdRec@.argList;
        if (workidr != NIL) {
            while (workidr != curIdRec) {
                scopeBound  =  NIL;
                P2672(scopeBound, workidr);
                workidr  =  workidr@.list;
            }
        };
        curFrameRegTemplate  =  curFrameRegTemplate - indexreg[1];
        curProcNesting  =  curProcNesting - 1;
    };
    if ((SY != BEGINSY) &&
       (not allowCompat || not (SY IN blockBegSys)))
        errAndSkip(84 /* errErrorInDeclarations */, skipToSet);
    } while (not (SY in statBegSys));
    if (preDefHead != ptr(0)) {
        error(85); /* errNotFullyDefinedVoids */
        while (preDefHead != ptr(0)) {
            printTextWord(preDefHead@.id);
            preDefHead  =  preDefHead@.preDefLink;
        };
        writeLN;
    };
    defineRoutine;
    while (numLabList != l2var16z) {
        if (not (numLabList@.defined)) {
            write(' ', numLabList@.id.i:0, ':');
            l2bool8z  =  false;
        };
        numLabList  =  numLabList@.next;
    };
    if (not l2bool8z) {
        printTextWord(l2idr2z@.id);
        error(90); /* errLblDefinitionInBlock */
    };
    l2arg1z  =  l2int21z;
}; /* programme */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void initTables;
var
    idx, jdx: int;
    l2unu3z, l2unu4z, l2unu5z: word;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void initInsnTemplates;
var
    l3var1z: insn;
    l3var2z: operator;
{
    for l3var1z  =  ATX to JADDM do
        insnTemp[l3var1z]  =  ord(l3var1z) * 010000;
    insnTemp[ELFUN]  =  0500000;
    jdx  =  KUTC;
    for l3var1z  =  UTC to VJM do {
        insnTemp[l3var1z]  =  jdx;
        jdx  =  (jdx + 0100000);
    };
    for idx to 15 do
        indexreg[idx]  =  idx * frameRegTemplate;
    jumpType  =  insnTemp[UJ];
    for l3var2z  =  MUL to ASSIGNOP do {
        opFlags[l3var2z]  =  opfCOMM;
        opToInsn[l3var2z]  =  0;
        if (l3var2z IN [MUL, RDIVOP, PLUSOP, MINUSOP]) {
            opToMode[l3var2z]  =  3;
        } else if (l3var2z IN [IDIVOP, IMODOP]) {
            opToMode[l3var2z]  =  2;
        } else if (l3var2z IN [IMULOP, INTPLUS, INTMINUS, badop27]) {
            opToMode[l3var2z]  =  1;
        } else if (l3var2z IN [badop30,badop31]) {
            opToMode[l3var2z]  =  4;
        } else {
            opToMode[l3var2z]  =  0;
        }
    };
    opToInsn[MUL]  =  insnTemp[AMULX];
    opToInsn[RDIVOP]  =  insnTemp[ADIVX];
    opToInsn[IDIVOP]  =  17; /* P/DI */
    opToInsn[IMODOP]  =  11; /* P/MD */
    opToInsn[PLUSOP]  =  insnTemp[ADD];
    opToInsn[MINUSOP]  =  insnTemp[SUB];
    opToInsn[IMULOP]  =  insnTemp[AMULX];
    opToInsn[SETAND]  =  insnTemp[AAX];
    opToInsn[SETXOR]  =  insnTemp[AEX];
    opToInsn[SETOR]  =  insnTemp[AOX];
    opToInsn[INTPLUS]  =  insnTemp[ADD];
    opToInsn[INTMINUS]  =  insnTemp[SUB];
    opToInsn[badop27]  =  22; /* P/II unused, undefined */
    opToInsn[badop30]  =  23; /* P/RR */
    opToInsn[badop31]  =  24; /* P/RI */
    opToInsn[MKRANGE]  =  61; /* P/PI */
    opToInsn[SETSUB]  =  insnTemp[AAX];
    opToInsn[SHLEFT]  =  insnTemp[ASN];
    opToInsn[SHRIGHT]  =  insnTemp[ASN];
    opFlags[AMPERS]  =  opfAND;
    opFlags[IDIVOP]  =  opfDIV;
    opFlags[OROP]  =  opfOR;
    opFlags[IMULOP]  =  opfMULMSK;
    opFlags[IMODOP]  =  opfMOD;
    opFlags[badop27]  =  opfHELP;
    opFlags[badop30]  =  opfHELP;
    opFlags[badop31]  =  opfHELP;
    opFlags[MKRANGE]  =  opfHELP;
    opFlags[ASSIGNOP]  =  opfASSN;
    opFlags[SETSUB]  =  opfINV;
    opFlags[SHLEFT]  =  opfSHIFT;
    opFlags[SHRIGHT]  =  opfSHIFT;
    for jdx  =  0 to 6 do {
        funcInsn[jdx]  =  (0500000 + jdx);
    }
}; /* initInsnTemplates */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void regKeywords;
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void regResWord(l4arg1z: int);
var
    kw: @kword;
    l4var2z: word;
{
    curVal.i  =  l4arg1z & hashMask.i;
    mapai(curVal.a, curVal.i);
    l4var2z.i  =  l4arg1z;
    new(kw);
    with kw@ do {
        w  =  l4var2z;
        sym  =  SY;
        op  =  charClass;
        next  =  kwordHashTabBase[curVal.i];
    };
    kwordHashTabBase[curVal.i]  =  kw;
    if (charClass == NOOP) {
        SY  =  succ(SY);
    } else {
        charClass  =  succ(charClass);
    }
}; /* regResWord */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /*=A3 regKeywords */
    SY  =  RELOP;
    charClass  =  INOP;
    regResWord('      IN');
    SY  =  NOTSY;
    charClass  =  NOOP;
    regResWord('     NOT');
    SY  =  LABELSY;
    charClass  =  NOOP;
    for idx  =  0 to 26 do
        regResWord(resWordNameBase[idx]);
}; /*=A2 regKeywords */
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void initArrays;
var
    l3var1z, l3var2z: word;
{
    FcstCnt  =  0;
    FcstCount  =  0;
    for idx  =  3 to 6 do {
        l3var2z.i  =  (idx - (2));
        for jdx to l3var2z.i do
            frameRestore[idx][jdx]  =  0;
    };
    for idx to 99 do
        helperMap[idx]  =  0;
}; /* initArrays */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void initSets;
{
    skipToSet  =  blockBegSys | statBegSys ~ [SWITCHSY];
    bigSkipSet  =  skipToSet | statEndSys;
}; /* initSets */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{ /* initTables */
    initArrays;
    initInsnTemplates;
    initSets;
    unpack(pasinfor.a3@, iso2text, '_052'); /* '*' */
    iso2text['_'] = iso2text['*'];
    rewrite(_CHILD_);
    for jdx to 10 do
        put(_CHILD_);
    for idx  =  0 to 127 do {
        symHashTabBase[idx]  =  NIL;
        typeHashTabBase[idx]  =  ;
        kwordHashTabBase[idx]  =  ;
    };
    regKeywords;
    numLabList  =  NIL;
    totalErrors  =  0;
    heapCallsCnt  =  0;
    putLeft  =  true;
    readNext  =  true;
    curFrameRegTemplate  =  frameRegTemplate;
    curProcNesting  =  1;
}; /* initTables */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void finalize;
var
    idx, cnt, unused: int;
    sizes: array [1..10] of @int;
{
    sizes[1]  =  ptr(1);
    sizes[2]  =  ptr(symTabPos - 074000 - 1);
    sizes[5]  =  ptr(longSymCnt);
    sizes[6]  =  ptr(moduleOffset - 040000);
    sizes[8]  =  ptr(FcstCnt);
    sizes[3]  =  ptr(0);
    sizes[4]  =  ;
    sizes[7]  =  ;
    sizes[9]  =  ptr(int92z);
    sizes[10]  =  ptr(int93z);
    curVal.i  =  moduleOffset - 040000;
    symTab[074001]  =  [24,29] | curVal.m ~ intZero;
    reset(FCST);
    while (not eof(FCST)) {
        write(_CHILD_, FCST@);
        get(FCST);
    };
    curVal.i  =  (symTabPos - 070000) * 0100000000;
    for cnt to longSymCnt do {
        idx  =  longSymTabBase[cnt];
        symTab[idx]  =  (symTab[idx] | (curVal.m & [9:23]));
        curVal.i  =  (curVal.i + 0100000000);
    };
    symTabPos  =  symTabPos - 1;
    for cnt  =  074000 to symTabPos do
        write(_CHILD_, symTab[cnt]);
    for cnt to longSymCnt do
        write(_CHILD_, longSyms[cnt]);
    if (allowCompat) {
        write((lineCnt - 1):6, ' LINES STRUCTURE ');
        for idx to 10 do
            write(ord(sizes[idx]):0, ' ');
        writeln;
    };
    entryPtTable[entryPtCnt]  =  [];
    pasinfor.entryptr@  =  entryPtTable;
    pasinfor.sizes  =  sizes;
}; /* finalize */
//
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
void initOptions;
{
    pasinfor.startOffset  =  pasinfor.startOffset - 16384;
    commentModeCH  =  ' ';
    lineNesting  =  0;
    CH  =  ' ';
    linePos  =  0;
    prevErrPos  =  0;
    errsInLine  =  0;
    lineCnt  =  1;
    checkFortran  =  false;
    bool110z  =  false;
    int93z  =  1;
    int92z  =  1;
    moduleOffset  =  16384;
    lineStartOffset  =  ;
    int94z  =  1;
    bool47z  =  false;
    dataCheck  =  ;
    heapSize  =  100;
    bool49z  =  true;
    atEOL  =  false;
    optSflags.i  =  pasinfor.flags << 39 >> 45;
    doPMD  =  not (42 in curVal.m);
    checkTypes  =  true;
    fixMult  =  true;
    fuzzReals  =  true;
    checkBounds  =  not (44 in curVal.m);
    declExternal  =  false;
    errors  =  false;
    allowCompat  =  false;
    fileBufSize  =  1;
    charEncoding  =  2;
    chain  =  NIL;
    longSymCnt  =  0;
    pasinfor.errors@  =  true;
    symTabCnt  =  0;
}; /* initOptions */
//
{ /* main */
    if (PASINFOR.listMode != 0)
        writeln(boilerplate);
    initOptions;
    curInsnTemplate  =  0;
    initTables;
    programme(curInsnTemplate, hashTravPtr);
    if (errors) {
9999:   writeln(' IN ', (lineCnt-1):0, ' LINES ',
            totalErrors:0, ' ERRORS');
    } else {
        finalize;
        PASINFOR.errors@  =  false;
    }
}
.data
    frameRegTemplate  =  04000000;
    constRegTemplate  =  I8;
    disNormTemplate  =   KNTR+7;
    blockBegSys  =  [LABELSY, CONSTSY, TYPESY, VARSY, FUNCSY, VOIDSY, BEGINSY];
    statBegSys  =   [BEGINSY, IFSY, SWITCHSY, DOSY, WHILESY, FORSY, WITHSY,
                    GOTOSY];
    hashMask  =  0203407U;
    statEndSys  =  [SEMICOLON, ENDSY, ELSESY, WHILESY];
    lvalOpSet  =  [GETELT, GETVAR, op36, op37, GETFIELD, DEREF, FILEPTR];
    /*=A3*/
    resWordNameBase  =
        '   LABEL',
        '   CONST',
        '    TYPE',
        '     VAR',
        'FUNCTION',
        '    VOID',
        '    ENUM',
        '  PACKED',
        '   ARRAY',
        '  STRUCT',
        '    FILE',
        '      IF',
        '  SWITCH',
        '   WHILE',
        '     FOR',
        '    WITH',
        '    GOTO',
        '    ELSE',
        '      OF',
        '      DO',
        '      TO',
        '  DOWNTO',
        '  EXTERN',
        ' DEFAULT';
/*=A2*/
    charSymTabBase  =  NOSY:128;
    chrClassTabBase  =  NOOP:128;
    charSymTabBase['0']  =  INTCONST:10;
    chrClassTabBase['0']  =  ALNUM:10;
    charSymTabBase['A']  =  IDENT:26;
    chrClassTabBase['A']  =  ALNUM:26;
    charSymTabBase['']  =  IDENT:31;
    chrClassTabBase['']  =  ALNUM:31;
    chrClassTabBase['_']  =  ALNUM;
    funcInsn[fnABS]  =  KAMX;
    funcInsn[fnTRUNC]  =  KADD+ZERO;
    funcInsn[fnODD]  =  KAAX+E1;
    funcInsn[fnORD]  =  KAOX+ZERO;
    funcInsn[fnCHR]  =  KAAX+MANTISSA;
    funcInsn[fnSUCC]  =  KARX+E1;
    funcInsn[fnPRED]  =  KSUB+E1;
    funcInsn[fnROUND]  =  macro + mcROUND;
    funcInsn[fnCARD]  =  macro + mcCARD;
    funcInsn[fnMINEL]  =  macro + mcMINEL;
    funcInsn[fnPTR]  =  KAAX+MANTISSA;
    funcInsn[fnABSI]  =  KAMX;
    iAddOpMap[PLUSOP]  =  INTPLUS, INTMINUS;
    imulOpMap  =  IMULOP, IDIVOP;
    charSymTabBase['''']  =  CHARCONST;
    charSymTabBase['_']  =  IDENT;
    charSymTabBase['<']  =  LTSY;
    charSymTabBase['>']  =  GTSY;
    chrClassTabBase['+']  =  PLUSOP;
    chrClassTabBase['-']  =  MINUSOP;
    chrClassTabBase['|']  =  OROP;
    chrClassTabBase['*']  =  MUL;
    chrClassTabBase['/']  =  RDIVOP;
    chrClassTabBase['%']  =  IMODOP;
    chrClassTabBase['^']  =  SETXOR;
    chrClassTabBase['=']  =  EQOP;
    chrClassTabBase['&']  =  AMPERS;
    chrClassTabBase['>']  =  GTOP;
    chrClassTabBase['<']  =  LTOP;
    chrClassTabBase['!']  =  NEOP;
    chrClassTabBase['~']  =  SETSUB;
    charSymTabBase['+']  =  ADDOP;
    charSymTabBase['-']  =  ADDOP;
    charSymTabBase['|']  =  ADDOP;
    charSymTabBase['*']  =  MULOP;
    charSymTabBase['/']  =  MULOP;
    charSymTabBase['%']  =  MULOP;
    charSymTabBase['&']  =  MULOP;
    charSymTabBase[',']  =  COMMA;
    charSymTabBase['.']  =  PERIOD;
    charSymTabBase['@']  =  ARROW;
    charSymTabBase['^']  =  MULOP;
    charSymTabBase['(']  =  LPAREN;
    charSymTabBase[')']  =  RPAREN;
    charSymTabBase[';']  =  SEMICOLON;
    charSymTabBase['[']  =  LBRACK;
    charSymTabBase[']']  =  RBRACK;
    charSymTabBase['=']  =  BECOMES;
    charSymTabBase[':']  =  COLON;
    charSymTabBase['!']  =  NOTSY;
    charSymTabBase['~']  =  ADDOP;
    /*=A3*/
    helperNames  =
        'P/1     ',
        'P/2     ',
        'P/3     ',
        'P/4     ',
        'P/5     ',
        'P/6     ',
        'P/CA    ',
        'P/EO    ',
        'P/SS    ',
/*10*/  'P/EL    ',
        'P/MD    ',
        'P/MI    ',
        'P/PA    ',
        'P/UN    ',
        'P/CP    ',
        'P/AB    ',
        'P/DI    ',
        'P/RC    ',
        'P/EA    ',
/*20*/  'P/NA    ',
        'P/BA    ',
        'P/II   u',
        'P/RR    ',
        'P/RI    ',
        'P/1D    ',
        'P/GD    ',
        'P/E     ',
        'P/EF    ',
        'P/PF    ',
/*30*/  'P/GF    ',
        'P/TF    ',
        'P/RF    ',
        'P/NW    ',
        'P/DS    ',
        'P/HT    ',
        'P/WI    ',
        'P/WR    ',
        'P/WC    ',
        'P/A6    ',
/*40*/  'P/A7    ',
        'P/WX    ',
        'P/WO    ',
        'P/CW    ',
        'P/6A    ',
        'P/7A    ',
        'P/WL    ',
        'P/RDI   ',
        'P/RDR   ',
        'P/RDC   ',
/*50*/  'P/RA6   ',
        'P/RA7   ',
        'P/RX   u',
        'P/RL    ',
        'P/WOLN  ',
        'P/RILN  ',
        'P/RR    ',
        'P/CE    ',
        'P/TR    ',
        'P/LV    ',
/*60*/  'P/ZAM  u',
        'P/PI    ',
        'P/BP    ',
        'P/B6    ',
        'P/PB    ',
        'P/B7    ',
        'P/IN    ',
        'P/IS    ',
        'P/DA    ',
        'P/CO    ',
/*70*/  'P/IT    ',
        'P/CK    ',
        'P/KC    ',
        'P/LNGPAR',
        'P/LDAR  ',
        'P/LDARIN',
        'P/00C   ',
        'P/STAR  ',
        'P/PMDSET',
        'P/CI    ',
/*80*/  'PAIB    ',
        'P/WA    ',
        'SQRT*   ',
        'SIN*    ',
        'COS*    ',
        'ARCTAN* ',
        'ARCSIN* ',
        'LN*     ',
        'EXP*    ',
        'P/EQ    ',
/*90*/  'P/RA    ',
        'P/GE    ',
        'P/MF    ',
        'P/FM    ',
        'P/NN    ',
        'P/SC    ',
        'P/DD    ',
        'P/RE    ';
    systemProcNames  =
/*0*/   '     PUT',
        '     GET',
        ' REWRITE',
        '   RESET',
        '     NEW',
        '    FREE',
        '    HALT',
        '    STOP',
        '   SETUP',
        '  ROLLUP',
/*10*/  '   WRITE',
        ' WRITELN',
        '    READ',
        '  READLN',
        '    EXIT',
        '   DEBUG',
        '    BESM',
        '   MAPIA',
        '   MAPAI',
        '     PCK',
/*20*/  '   UNPCK',
        '    PACK',
        '  UNPACK';
}
